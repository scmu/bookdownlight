<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head>
<title>bookdownlight</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<script type="text/javascript"
    src="https://www.maths.nottingham.ac.uk/plp/pmadw/LaTeXMathML.js">
</script>
<link rel="stylesheet" href="mystyle.css">
</head>
<body class="introcontent">


<div class='main' >
    <div>
        <h1 class="container">
        <p> 程式設計：函數程式語言 </p>
        </h1>
    </div>
    <nav>
        <ul class="container">
            <li><a href="Introduction.html"> Introduction </a></li>
            <li><a href="Basics.html"> Basics </a></li>
            <li><a href="Induction.html"> Induction </a></li>
            <li><a href="Semantics.html"> Semantics </a></li>
            <li><a href="Derivation.html"> Derivation </a></li>
            <li><a href="Folds.html"> Folds </a></li>
        </ul>
    </nav>


<div class="book">

<div><pre style='display:none'>
{-# LANGUAGE TypeOperators #-}
module Chapters.Derivation where

import Prelude ()
import Control.Arrow ((***))
import Data.List (inits, tails)
import Common.MiniPrelude hiding (exp, gcd)

import Chapters.Basics (square, ETree(..), ITree(..), positions, fork)
</pre></div>
 <h1 class='chapter'>程式推導<id='ch:derivation'></h1><p><em>程式推導</em>(<em>program derivation</em>) index program derivation 程式推導 是本書的重要主題。給定一個待解決的問題，並假設該問題的規格(specification)能寫成邏輯、數學、或其他形式語言，程式推導泛指以嚴謹方式將該規格轉換成一個解決該問題的程式的方法。指令式語言與函數語言都能做程式推導，而且有許多道理可相通。本書討論函數語言的程式推導。一個簡單、典型的函數程式語言推導可能有如下的形式：</p>
%{
%format en = "\Varid{e}_{\Varid{n}}"<br>22
<div><pre class='spec'>
  spec
=  {- 性質 1 -}
  e1
=  {- 性質 2 -}
  ....
=  {- 性質 n -}
  en {-"~~."-}
</pre></div>
其中 <code class='haskell'>spec</code> 是問題的規格，通常也是一個函數語言程式。根據性質 1, <code class='haskell'>spec</code> 等於 <code class='haskell'>e1</code>；根據性質 2，<code class='haskell'>e1</code> 等於 <code class='haskell'>e2</code>... 長此以往，直到我們導出一個符合我們要求的 <code class='haskell'>en</code>.光這麼看來，這和我們前幾章作的數學證明似乎沒什麼不同。差別在於，做證明時我們已有 <code class='haskell'>spec</code> 和 <code class='haskell'>en</code>，要做的是把 <code class='haskell'>spec</code> 到 <code class='haskell'>en</code> 之間的步驟補足。但做程式推導時，我們是從 <code class='haskell'>spec</code> 出發，希望透過種種跡象找出一個滿意的（可能是夠快的、不佔空間的、或滿足某些其他性質的）<code class='haskell'>en</code>.當然，找出 <code class='haskell'>en</code> 之後，從 <code class='haskell'>spec</code> 推出 <code class='haskell'>en</code> 的過程就成了 <code class='haskell'>spec = en</code> 的證明。當程式推導的進行方式類似數學演算，有人可能稱之為<em>程式演算</em>(<em>program calculation</em>) index program calculation 程式演算 。本書混用這兩個詞彙，並不區分。<br>
<p>為何做程式推導？第一個理由是我們希望程式正確。此處的「正確」指的是 <code class='haskell'>en</code> 確實滿足了最初的規格 <code class='haskell'>spec</code>。但如果只為了正確性，我們為何不能先無論如何把 <code class='haskell'>en</code> 寫出，再試著證明 <code class='haskell'>spec = en</code>？原因之一是通常程式寫好了，大家便不想證它了。更重要的是：程式開發時，若沒有把「怎麼證明它」列入考量，寫出的程式常常是很難證明的。為了確保有證明，最好讓「產生證明」這件事情成為程式開發過程中的一部分，甚至讓證明引導程式的開發。Dijkstra 說道：</p>
<blockquote>
<p>先給一個程式再證明它，在某個意義上是把馬車放在馬前面。更有希望的做法是讓正確性證明與程式一起長出來：如此一來，我們能選擇證明的結構，然後設計一個能用這種方法證明出來的程式。這還有個額外的好處：正確性考量可以成為程式該怎麼寫的引導與啟發。\citep{Dijkstra:74:Programming}</p>
</blockquote>
   % to prove the correctness of a given program, was in a sense putting the cart before the horse. A much more promising approach turned out to be letting correctness proof and program grow hand in hand: with the choice of the structure of the correctness proof one designs a program for which this proof is applicable. The fact that then the correctness concerns turn out to act as an inspiring heuristic guidance is an added benefit.\cite{Dijkstra:74:Programming}<br>22
<p>Dijkstra 的最後一句話帶到了程式推導的第三個理由：提倡者認為，程式推導的種種方法與技巧可以引導我們去分析、思考、解決問題；這是解問題、甚至發現新演算法的方法（ citet Backhouse:03:Program ,  citet Backhouse:11:Algorithmic ）。藉由良好的符號設計，我們可以發現常見的程式推導模式，並將其推廣到其他有類似性質的問題上。</p>
%} % format en<br>22
<p>在第 ref ch:intro 章的結尾我們說「函數語言的價值便是：它是個適於演算的語言。」便於做程式推導，是我覺得函數語言最突出的特質。我們可以由規格出發、在符號上操作，將程式如同求代數的解一樣地算出來。只要每個小步驟都正確，最後的程式就是正確的。由第 ref ch:basics 章至今，我們做了許多準備工作，備齊需要的基本知識。現在我們終於可以開始做一些演算了。</p>
<h2 class='section' >展開-收回轉換<id='sec:fold-unfold-transform'></h2><p>考慮這麼一個例子：給定一個整數形成的串列，我們想計算其每個數的平方的和。例如當輸入是<code class='haskell'>[2,6,5,3]</code>, 我們希望算出 $2^2 + 6^2 + 5^2 + 3^2 = 74$. 這項工作可以簡短地描述如下：</p>
\begin{flalign}
\qquad\quad
|sumsq| &|= sum . map square {-"~~."-}| &
\label{eq:sumsq-oneliner}
\end{flalign}<br>22

<div><pre style='display:none'>
sumsq :: List Int -> Int
sumsq = sum . map square
</pre></div>
 <p>函數 <code class='haskell'>sumsq</code> 的型別為 <code class='haskell'>List Int -> Int</code>.其中 <code class='haskell'>map square</code> 將輸入串列的每個元素都平方，然後由 <code class='haskell'>sum</code> 計算其總和。第 ref sec:induction-lists 節中給過一個 <code class='haskell'>sum</code> 的歸納定義，重複如下：</p>
<div><pre class='spec'>
sum :: List Int -> Int
sum []      = 0
sum (x:xs)  = x + sum xs {-"~~."-}
</pre></div>
消除中間串列 對大部分的應用而言，如上定義的 <code class='haskell'>sumsq</code> 已經很堪用了。但作為一個例子，我們來挑惕些仍不滿意之處。執行 <code class='haskell'>sumsq xs</code> 時，<code class='haskell'>map square</code> 會產生另一個（存放 <code class='haskell'>xs</code> 每個元素的平方的）串列，該串列隨即由 <code class='haskell'>sum</code> 消掉 --- 感覺上似乎很浪費空間與時間。<p class='footer'>在惰性求值的情況下，該中間串列的<em>每個</em>節點被產生後立刻被 <code class='haskell'>sum</code> 消去，因此不會真的佔用和 <code class='haskell'>xs</code> 同樣長度的空間。這也是大家覺得惰性求值有助於模組化、使小函數變得易於重用的例子之一。但「產生一個新節點、立刻消去」仍耗了一些不必要的時間。</p>有不產生這個中間串列的方法嗎？<br>
<p>我們試著做些計算。當 <code class='haskell'>sumsq</code> 的參數是 <code class='haskell'>[]</code> 時：</p>

<div><pre style='display:none'>
sumsqDer0 :: Int
sumsqDer0 =
</pre></div>
 <div><pre style='display:none'>
   sumsq []
 ===    {- |sumsq| 之定義 -}
   sum (map square [])
 ===    {- |map| 之定義 -}
   sum []
 ===    {- |sum| 之定義 -}
   0 {-"~~."-}
</pre></div>
由此我們得知 <code class='haskell'>sumsq []</code> 會被計算成 <code class='haskell'>0</code>. 當輸入不是空串列時呢？試計算：<br>

<div><pre style='display:none'>
sumsqDer1 :: Int -> List Int -> Int
sumsqDer1 x xs =
</pre></div>
 <div><pre style='display:none'>
   sumsq (x:xs)
 ===    {- |sumsq| 之定義 -}
   sum (map square (x:xs))
 ===    {- |map| 之定義 -}
   sum (square x : map square xs)
 ===    {- |sum| 之定義 -}
   square x + sum (map square xs)
 ===    {- |sumsq| 之定義 -}
   square x + sumsq xs {-"~~."-}
</pre></div>
可得知對任何 <code class='haskell'>x</code> 與 <code class='haskell'>xs</code>, <code class='haskell'>sum (x:xs)</code> 歸約的結果和 <code class='haskell'>square x + sumsq xs</code> 會是相同的。總結說來，藉由計算，我們發現 <code class='haskell'>sumsq</code> 滿足以下兩條性質：<br>
\begin{flalign}
\qquad\quad
\begin{split}
|sumsq []|      &|= 0| \\
|sumsq (x:xs)|  &|= square x + sumsq xs {-"~~."-}|
\end{split} &
\label{eq:sumsq-inductive}
\end{flalign}<br>22
<p>但如果我們翻轉過來，把這兩條性質當作 <code class='haskell'>sumsq</code> 的新定義呢？這是一個依據歸納法定義的良好程式，而且不會產生中間串列！</p>
<p>但我們怎知道 <code class='haskell'>sumsq</code> 的新定義滿足我們最初的要求  eqref eq:sumsq-oneliner ，即 <code class='haskell'>sumsq = sum . map square</code> 呢？回顧起來，我們的演算只證明了當 <code class='haskell'>sumsq</code> 滿足  eqref eq:sumsq-oneliner ，它也滿足  eqref eq:sumsq-inductive ，卻還不能據此宣稱另一個方向：若  eqref eq:sumsq-inductive  成立， eqref eq:sumsq-oneliner  也成立。我們將在第 \todo{???} 節詳細討論這個問題。目前可暫時這麼說：如果我們從某個問題規格 <code class='haskell'>f = e</code> 起始，發現 <code class='haskell'>f</code> 滿足某一組等式，而這些等式剛好可湊成一個<em>會正常終止</em>的歸納定義，則 <code class='haskell'>e</code> 確實是唯一滿足這些等式的解。由於如此的 <code class='haskell'>e</code> 是唯一的，我們也可倒過來以這組等式為 <code class='haskell'>f</code> 的定義，並同時宣稱 <code class='haskell'>f = e</code> 這個性質成立。</p>
<p>回顧起來，在 <code class='haskell'>sumsq</code> 的計算中，我們僅是把 <code class='haskell'>sumsq</code> 的定義展開，接著展開 <code class='haskell'>map</code>, <code class='haskell'>sum</code> 等等元件的定義，直到我們又看到 <code class='haskell'>sumsq</code> 的定義出現在式子中、剛好可以收回為止。這是一種單純而歷史悠久的程式推導方法，稱作<em>展開-收回轉換</em>(<em>fold-unfold transformation</em>) index fold-unfold transformation 展開-收回轉換 。雖然簡單，有時這個方法意外地有用。</p>
<p>在這個例子中，我們真正做到的是將一個單行、使用全麥編程的 <code class='haskell'>sumsq</code> 定義轉換成了一個歸納定義。新定義的 <code class='haskell'>sumsq</code> 比起原版稍有效率些，但這只是恰巧發生的 --- 歸納定義的程式不見得總會比較有效率。程式推導確保程式的正確性 --- 意即<em>導出的程式與原本的規格是同一個函數</em>。但新程式的效率仍須單獨分析。這是下一節的主題。</p>
% ```haskell
% pos :: Eq a => a -> List a -> Int
% pos x = length . takeWhile (x /=) {-"~~."-}
% ```
%
% %if False
% ```haskell
% posDer1 =
% ```
% %endif
% ```haskell
%       pos x (y:ys)
%  ===    {- |pos| 之定義 -}
%       length (takeWhile (x /=) (y : ys))
%  ===    {- |takeWhile| 之定義 -}
%       length (if x /= y  then y : takeWhile (x /=) ys else [])
%  ===    {- \eqref{eq:fn-if-distribute}, |length| 之定義 -}
%       if x /= y  then Suc (length (takeWhile (x /=) ys)) else Zero
%  ===    {- |pos| 之定義 -}
%       if x /= y  then Suc (pos x ys) else Zero {-"~~."-}
% ```
% ```spec
% pos :: Eq a => a -> List a -> Int
% pos x []      =
% pos x (y:ys)  = if x /= y  then Suc (pos x ys) else Zero {-"~~."-}
% ```<br>22
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b><id='ex:descend'>
<p>下述函數 <code class='haskell'>descend n</code> 傳回 <code class='haskell'>[n, n-1, n-2...0]</code>:</p>
<div><pre style='display:none'>
descend :: Nat -> List Nat
descend Zero     = []
descend (Suc n)  = Suc n : descend n {-"~~."-}
</pre></div>
定義 <code class='haskell'>sumseries = sum . descend</code>.請找出 <code class='haskell'>sumseries</code> 的歸納定義。<br>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>顯然 <code class='haskell'>sum (descend 0) = 0</code>. 考慮歸納情況：</p>

<div><pre style='display:none'>
sumDescendDer1 :: Nat -> Nat
sumDescendDer1 n =
</pre></div>
 <div><pre style='display:none'>
   sum (descend (Suc n))
 ===   {- |descend| 之定義 -}
   sum (Suc n : descend n)
 ===   {- |sum| 之定義 -}
   (Suc n) +: sum (descend n)
 ===   {- |sumseries| 之定義 -}
   (Suc n) +: sumseries n {-"~~."-}
</pre></div>
因此<br>
<div><pre style='display:none'>
sumseries Zero     = Zero
sumseries (Suc n)  = (Suc n) +: sumseries n {-"~~."-}
</pre></div>
</div>
</div>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b><id='ex:repeatN'>
<p>承接習題 ref ex:descend 。函數 <code class='haskell'>repeatN :: (Nat :* a) -> List a</code> 的定義為</p>
<div><pre class='spec'>
repeatN (n,x) = map (const x) (descend n) {-"~~."-}
</pre></div>
因此，<code class='haskell'>repeatN (n,x)</code> 會傳回一個含 <code class='haskell'>n</code> 個 <code class='haskell'>x</code> 的串列。例如 <code class='haskell'>repeatN (3,'a') = "aaa"</code>.請算出一個歸納定義的 <code class='haskell'>repeatN</code>.<br>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>顯然 <code class='haskell'>repeatN (0,x) = []</code>.至於歸納情況，演算如下：</p>

<div><pre style='display:none'>
repeatNDer1 :: Nat -> a -> List a
repeatNDer1 n x =
</pre></div>
 <div><pre style='display:none'>
   repeatN (Suc n, x)
 ===   {- |repeatN| 之定義 -}
   map (const x) (descend (Suc n))
 ===   {- |descend| 之定義 -}
   map (const x) (Suc n : descend n)
 ===   {- |map| 與 |const| 之定義 -}
   x : map (const x) (descend n)
 ===   {- |repeatN| 之定義 -}
   x : repeatN (n,x) {-"~~."-}
</pre></div>
因此，<br>
<div><pre style='display:none'>
repeatN (Zero,   x)  = []
repeatN (Suc n,  x)  = x : repeatN (n,x) {-"~~."-}
</pre></div>
</div>
</div>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b><id='ex:rld'>
<p>承接習題 ref ex:repeatN 。遊程編碼(run-length encoding) index run-length encoding 遊程編碼 是一種簡單的壓縮方式：將字串中重複的字元表達成其出現的數字。例如 <code class='haskell'>"aaabbbbcdd"</code> 可以表達為 <code class='haskell'>"3a4b1c2d"</code>. 下列函數 <code class='haskell'>rld :: List (Nat :* a) -> List a</code> 則是抽象過的「遊程解碼」，將已經表示成（次數$\times$字元）的壓縮文展開：</p>
<div><pre class='spec'>
rld = concat . map repeatN {-"~~."-}
</pre></div>
例如， <code class='haskell'>rld [(2,'a'), (3,'b'), (1,'c')] = "aabbbc"</code>.請導出 <code class='haskell'>rld</code> 的歸納定義。<br>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>基底狀況：</p>
<div><pre class='spec'>
   rld []
=    {- |rld| 之定義 -}
   concat (map repeatN [])
=    {- |map| 與 |concat| 之定義 -}
   [] {-"~~."-}
</pre></div>
歸納狀況：<br>

<div><pre style='display:none'>
rldDer1 :: Nat -> a -> List (Nat, a) -> List a
rldDer1 n x xs =
</pre></div>
 <div><pre style='display:none'>
      rld ((n,x):xs)
 ===    {- |rld| 之定義 -}
      concat (map repeatN ((n,x):xs))
 ===    {- |map| 之定義 -}
      concat (repeatN (n,x) : map repeatN xs)
 ===    {- |concat| 之定義 -}
      repeatN (n,x) ++ concat (map repeatN xs)
 ===    {- |rld| 之定義 -}
      repeatN (n,x) ++ rld xs {-"~~."-}
</pre></div>
因此我們已推導出：<br>
<div><pre style='display:none'>
rld []          = []
rld ((n,x):xs)  = repeatN (n,x) ++ rld xs {-"~~."-}
</pre></div>
</div>
</div>
% :::{.exer #ex:pos-length-takeWhile}
% There is another way to define |pos| such that
% |pos x xs| yields the index of the first occurrence of |x| in |xs|:
% ```spec
% pos :: Eq a => a -> List a -> Int
% pos x = length . takeWhile (x /=) {-"~~."-}
% ```
% (This |pos| behaves differently from the one in the lecture when
% |x| does not occur in |xs|.) Construct an inductive definition
% of |pos|.<br>22
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>下列函數 <code class='haskell'>delete</code> 將輸入串列中的每個元素輪流刪除：</p>
<div><pre style='display:none'>
delete         ::  List a -> List (List a)
delete []      =   []
delete (x:xs)  =   xs : map (x:) (delete xs) {-"~~,"-}
</pre></div>
例如，<code class='haskell'>delete [1,2,3,4] = [[2,3,4], [1,3,4], [1,2,4], [1,2,3]]</code>.函數 <code class='haskell'>select :: List a -> List (a :* List a)</code> 則將一個串列中的元素依次選出。例如，<code class='haskell'>select [1,2,3,4] = [(1,[2,3,4]), (2,[1,3,4]), (3,[1,2,4]), (4,[1,2,3])]</code>. 函數 <code class='haskell'>select</code> 恰巧可用 <code class='haskell'>delete</code> 定義出來：<br>
<div><pre style='display:none'>
select xs = zip xs (delete xs) {-"~~."-}
</pre></div>
請推導出 <code class='haskell'>select</code> 的歸納定義。<b>提示</b>：下述性質可能有用 ---<code class='haskell'>zip xs (map f ys) = map (id *** f) (zip xs ys)</code>.<br>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>顯然 <code class='haskell'>select [] = []</code>。考慮 <code class='haskell'>xs := x:xs</code> 的情況：</p>

<div><pre style='display:none'>
selectDer1 x xs =
</pre></div>
 <div><pre style='display:none'>
    select (x:xs)
 ===   {- |select| 與 |delete| 之定義 -}
    zip (x:xs) (xs : map (x:) (delete xs))
 ===   {- |zip| 之定義 -}
    (x, xs) : zip xs (map (x:) (delete xs))
 ===   {- |zip xs (map f ys) = map (id *** f) (zip xs ys)| -}
    (x, xs) : map (id *** (x:)) (zip xs (delete xs))
 ===   {- |select| 之定義 -}
    (x, xs) : map (id *** (x:)) (select xs) {-"~~."-}
</pre></div>
因此，<br>
<div><pre class='spec'>
select []      = []
select (x:xs)  = (x, xs) : map (id *** (x:)) (select xs) {-"~~."-}
</pre></div>
</div>
</div>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>函數 <code class='haskell'>delete</code> 有另一個可能定義：</p>
<div><pre class='spec'>
delete xs = map (del xs) [0..length xs-1]
   where del xs i = take i xs ++ drop (1+i) xs {-"~~,"-}
</pre></div>
（此處我們利用了當 <code class='haskell'>n</code> 為負數時，<code class='haskell'>[0..n]</code> 化簡成 <code class='haskell'>[]</code> 的特性。）請用此定義推導出 <code class='haskell'>delete</code> 的歸納定義。<b>提示</b>：你可能用得上下述性質：<br>
<div><code class='haskell'><id='eq:gen-split'>
  |[0..n] = 0 : map (1+) [0..n-1]|\mbox{,~~ if |n >= 0|,}
</code></div>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>以下只列出歸納狀況：</p>

<div><pre style='display:none'>
deleteDer1 x xs =
</pre></div>
 <div><pre style='display:none'>
    delete (x:xs)
 ===   {- |delete| 之定義 -}
    map (del (x:xs)) [0..length (x:xs) -1]
 ===   {- |length| 之定義，簡單運算 -}
    map (del (x:xs)) [0..length xs]
 ===   {- 由於 |length xs >= 0|, 使用 \eqref{eq:gen-split} -}
   map (del (x:xs)) (0 : map (1+) [0..length xs-1])
 ===   {- |map| 之定義 -}
   del (x:xs) 0 : map (del (x:xs)) (map (1+) [0..length xs-1])
 ===   {- |map| 融合 -}
   del (x:xs) 0 : map (del (x:xs) . (1+)) [0..length xs-1] {-"~~."-}
</pre></div>
在此暫停一下，觀察 <code class='haskell'>del (x:xs)</code>. 顯然, <code class='haskell'>del (x:xs) 0 = xs</code>. 至於 <code class='haskell'>del (x:xs) . (1+)</code>，我們演算看看:<br>

<div><pre style='display:none'>
del xs i = take i xs ++ drop (1+i) xs

delSucDer x xs i =
</pre></div>
 <div><pre style='display:none'>
    (del (x:xs) . (1+)) i
 ===    {- |(.)| 與 |del| 之定義 -}
    take (1+ i) (x:xs) ++ drop (1+ (1+ i)) (x:xs)
 ===    {- |take| 與 |drop| 之定義 -}
    x : take i xs ++ drop (1+ i) xs
 ===    {- |del| 之定義 -}
    x : del xs i
 ===    {- |(.)| 之定義 -}
    ((x:) . del xs) i {-"~~."-}
</pre></div>
繼續之前的演算：<br>

<div><pre style='display:none'>
deleteDer2 x xs =
</pre></div>
 <div><pre style='display:none'>
    del (x:xs) 0 : map (del (x:xs) . (1+)) [0 .. length xs - 1]
 ===   {- 前述之演算 -}
    xs : map ((x:) . del xs) [0 .. length xs - 1]
 ===   {- |map| 融合 -}
    xs : map (x:) (map (del xs) [0 .. length xs - 1])
 ===   {- |delete| 之定義 -}
    xs : map (x:) (delete xs) {-"~~."-}
</pre></div>
由此，我們導出了正文中 <code class='haskell'>delete</code> 的歸納定義.<br>
</div>
</div>
<h2 class='section' >關於執行效率<id='sec:efficiency-basics'></h2><p>有點意外地，本書直到現在才較正式地談執行效率。在本書中，我們假設數字四則運算、邏輯運算元等等都可在常數時間內完成。資料結構方面，使用資料建構元或對其做樣式配對都只需要常數時間。例如，將 <code class='haskell'>x</code> 與 <code class='haskell'>y</code> 做成 <code class='haskell'>(x,y)</code> 是常數時間內可完成的動作；一個型別是序對的值如果已經是弱首範式，將其配對成 <code class='haskell'>(x,y)</code> 以取出其中的 <code class='haskell'>x</code> 和 <code class='haskell'>y</code> 也只需要常數時間。如果有資料結構定義 <code class='haskell'>data T = A || B</code>, 給一個已經是弱首範式的 <code class='haskell'>x :: T</code>, 只需常數時間便可判斷它究竟是 <code class='haskell'>A</code> 還是 <code class='haskell'>B</code>.</p>
<p>回顧 <code class='haskell'>List</code> 的定義：</p>
<div><pre class='spec'>
data List a = [] | a : List a {-"~~."-}
</pre></div>
我們可看出這是一個偏一邊的表示法。對於串列的左邊的操作都可以在常數時間內完成。因此，我們可在常數時間內判斷一個串列 <code class='haskell'>xs</code> 究竟是 <code class='haskell'>[]</code> 還是可分解成頭和尾；產生 <code class='haskell'>[]</code> 只需要常數時間；在 <code class='haskell'>xs</code> 的左邊添加一個元素，傳回 <code class='haskell'>x:xs</code>，也是常數時間內可完成的動作。但如果我們要拿出某串列最右邊的元素，或著在串列的右邊加東西呢？回顧 <code class='haskell'>(++)</code> 的定義：<br>
<div><pre class='spec'>
(++) :: List a -> List a -> List a
[]      ++ ys  = ys
(x:xs)  ++ ys  = x : (xs ++ ys) {-"~~."-}
</pre></div>
若我們試著看看 <code class='haskell'>[1,2,3] ++ [4,5]</code> 是怎麼被算出來的<br>
<div><pre class='spec'>
   (1 : 2 : 3 : []) ++ (4 : 5 : [])
=  1 : ((2 : 3 : []) ++ (4 : 5 : []))
=  1 : 2 : ((3 : []) ++ (4 : 5 : []))
=  1 : 2 : 3 : ([] ++ (4 : 5 : []))
=  1 : 2 : 3 : 4 : 5 : [] {-"~~,"-}
</pre></div>
可發現 <code class='haskell'>(++)</code> 需把第一個參數從頭到尾走過一遍。因此，若第一個參數的長度是 <code class='haskell'>n</code>，<code class='haskell'>(++)</code> 是一個時間複雜度為 $O(n)$ 的函數。函數 <code class='haskell'>last</code> 的情況也類似。<br>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>回顧 <code class='haskell'>last</code> 的定義，試著展開 <code class='haskell'>last [1,2,3,4]</code> 並確認 <code class='haskell'>last xs</code> 需要的時間是否為 $O(|length xs|)$。</p>
</div>
</div>
<p>諸如 <code class='haskell'>sum</code>, <code class='haskell'>length</code>, <code class='haskell'>maximum</code> 之類的函數將串列從頭到尾走過一次。當輸入串列長度為 <code class='haskell'>n</code>, 它們均需時 $O(n)$。如果函數 <code class='haskell'>f</code> 需時 $O(t)$，<code class='haskell'>map f</code> 需時 $O(t\times n)$.函數 <code class='haskell'>filter p</code>, <code class='haskell'>takeWhile p</code> 等等在最壞情況下需將串列走完，因此它們也是需要線性時間的函數。函數 <code class='haskell'>zip</code> 需要的時間與兩個串列中較短者成正比。</p>
<p>在習題  ref ex:reverse  中，我們曾請讀者定義一個函數 <code class='haskell'>reverse :: List a -> List a</code>，將輸入的串列反轉，例如 <code class='haskell'>reverse [1,2,3,4,5] = [5,4,3,2,1]</code>. 一個可能的答案如下：</p>
<div><pre class='spec'>
reverse []      = []
reverse (x:xs)  = reverse xs ++ [x] {-"~~."-}
</pre></div>
這個程式的效率如何呢？我們看看 <code class='haskell'>reverse [1,2,3,4]</code> 如何被歸約：<br>
<div><pre class='spec'>
   reverse [1,2,3,4]
=  reverse [2,3,4] ++ [1]
=  (reverse [3,4] ++ [2]) ++ [1]
=  ((reverse [4] ++ [3]) ++ [2]) ++ [1]
=  (((reverse [] ++ [4]) ++ [3]) ++ [2]) ++ [1]
=  ((([] ++ [4]) ++ [3]) ++ [2]) ++ [1] {-"~~."-}
</pre></div>
為了把 <code class='haskell'>[1]</code> 接在左邊，<code class='haskell'>(++ [1])</code> 需要走過一個長度為 <code class='haskell'>3</code> 的串列。而在那之前，<code class='haskell'>(++ [2])</code> 需要走過一個長度為 <code class='haskell'>2</code> 的串列。推廣說來，要反轉一個長度為 <code class='haskell'>n</code> 的串列，<code class='haskell'>(++)</code> 會被使用 $O(n)$ 次。每個 <code class='haskell'>(++)</code> 左邊的串列長度也是 $O(n)$，因此 <code class='haskell'>reverse</code> 是一個需時 $O(n^2)$ 的演算法！「反轉串列」這個看來很基本的操作竟需要 $O(n^2)$ 的時間，似乎令人難以接受。是否有更快的做法呢？我們將在第  ref sec:accumulating-param  節討論到。<br>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b><id='ex:ETree-tips'>
<p>回顧第 ref sec:user-defined-data 與 ref sec:other-inductive-datatypes 節中提及的外標籤二元樹：</p>
<div><pre class='spec'>
data ETree a  = Tip a | Bin (ETree a) (ETree a) {-"~~."-}
</pre></div>
以下函數傳回樹中所有的標籤：<br>
<div><pre style='display:none'>
tips :: ETree a -> List a
tips (Tip x)    = [x]
tips (Bin t u)  = tips t ++ tips u {-"~~."-}
</pre></div>
函數 <code class='haskell'>tips</code> 最壞情況的時間複雜度為何？請做出一個含有 <code class='haskell'>n</code> 個標籤的樹 <code class='haskell'>t</code>，使得 <code class='haskell'>tips t</code> 僅需要 $O(n)$ 的時間算完；也請做出一個含有 <code class='haskell'>n</code> 個標籤的樹 <code class='haskell'>u</code>，使得 <code class='haskell'>tips u</code> 需要 $O(n^2)$ 的時間。<br>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>令 <code class='haskell'>t</code> 為一個向右傾斜的樹：</p>
<div><pre class='spec'>
t = Bin (Tip 1) (Bin (Tip 2) .. (Bin (Tip (n-1)) (Tip n))) {-"~~,"-}
</pre></div>
<code class='haskell'>tip t</code> 展開成為 <code class='haskell'>[1] ++ ([2] .. ([n-1] ++ [n]))</code>, 可在 $O(n)$ 時間內歸約成範式。這是最好的情況。令 <code class='haskell'>u</code> 為一個向左傾斜的樹：<br>
<div><pre class='spec'>
u =  Bin (Bin (... (Bin (Bin (Tip 1) (Tip 2)) (Tip 3)))...
       (Tip (n-1))) (Tip n) {-"~~,"-}
</pre></div>
<code class='haskell'>tip u</code> 展開成為 <code class='haskell'>((..(([1] ++ [2])++[3])..) .. ++ [n-1]) ++ [n]</code>, 需要 $O(n^2)$ 的時間，也是 <code class='haskell'>tips</code> 最壞情況的時間複雜度.<br>
</div>
</div>
<h2 class='section' >用展開-收回轉換增進效率<id='sec:fold-unfold-transform-efficiency'></h2><p>在前面的例子中，我們手動推導出的 <code class='haskell'>sumsq</code> 只比原來的版本快了一點點，並沒有複雜度上的改進。本節我們來看一些使用程式推導改進複雜度的例子。</p>
<h3 class='subsection' >計算多項式 -- Horner 法則<id='sec:poly-horner'></h3><p>給定整數串列 $\Varid{as} = [a_0, a_1, a_2 \ldots a_n]$ 以及 <code class='haskell'>x :: Int</code>, 我們想計算如下的多項式：</p>
<div><code class='haskell'>
    a_0 + a_1 x + a_2 x^2 + ... + a_n x^n \mbox{~~.}
</code></div>
<p>這問題的規格能清楚寫成：</p>
<div><pre style='display:none'>
poly x as = sum (zipWith (*) as (iterate (* x) 1)) {-"~~,"-}
</pre></div>
其中 <code class='haskell'>iterate (* x) 1</code> 產生無限串列 $[1, x, x^2, x^3 ...]$, <code class='haskell'>zipWith</code> 計算 $[a_0, a_1 x, \ldots a_n x^n]$, <code class='haskell'>sum</code> 計算總和。<br>
<p>讀者應已對 <code class='haskell'>sum</code> 和 <code class='haskell'>zipWith</code> 很熟悉了。函數 <code class='haskell'>iterate</code> 在第  ref sec:list-generation  節中使用過，<code class='haskell'>iterate f x</code> 會展開為無限長的串列 <code class='haskell'>[x, f x, f (f x)...]</code>，每個元素分別是把 <code class='haskell'>f</code> 使用<code class='haskell'>0</code>次、<code class='haskell'>1</code>次、<code class='haskell'>2</code>次... 的結果。函數 <code class='haskell'>iterate</code> 可定義為</p>
<div><pre class='spec'>
iterate :: (a -> a) -> a -> List a
iterate f x = x : map f (iterate f x) {-"~~."-}
</pre></div>
我們可將之理解成：<code class='haskell'>iterate f x</code> 的第一個元素是 <code class='haskell'>x</code>；剩下的元素呢？是把 <code class='haskell'>iterate f x</code> 本身拿來，對每個元素多做一次 <code class='haskell'>f</code>!<br>
<p>讀到此的讀者可能有些疑問：這是一個合法的歸納定義嗎？以及，我們原已說定不談無限的資料結構，何以在此卻出現了呢？</p>
<p>上述 <code class='haskell'>iterate</code> 的定義方式確實不是歸納，而是「餘歸納」(coinduction)的一個例子。 index coinduction 餘歸納 第 ref sec:induction-set-theory 節中曾提及，餘歸納與歸納互為對偶，以餘歸納定義出的資料結構稱作「餘資料」，可以是能無限地展開的。 index codata 餘資料 「餘串列」和歸納定義的串列應該視為不同的型別，但它們可共存於同一個程式中，只要我們確定不在餘資料上做歸納定義或證明。</p>
<p>為培養一些對 <code class='haskell'>iterate</code> 的直覺，我們試著展開它：</p>
<div><pre class='spec'>
  iterate f x
=   {- |iterate| 之定義 -}
  x : map f (iterate f x)
=   {- |map| 之定義 -}
  x : map f (x : map f (iterate f x))
=   {- |map| 融合 -}
  x : f x : map (f . f) (iterate f x)
=   {- |iterate| 與 |map| 之定義 -}
  x : f x : f (f x) : map (f . f) (map f (iterate f x))
=   {- |map| 融合 -}
  x : f x : f (f x) : map (f . f . f) (iterate f x)
</pre></div>
可發現越展開，式子中便累積越多個 <code class='haskell'>map f</code>.<br>
<p>在 <code class='haskell'>poly</code> 之中，<code class='haskell'>iterate</code> 雖產生無限長的餘資料，但立刻被 <code class='haskell'>zipWith</code> 截短了。<p class='footer'>此處我們假設 <code class='haskell'>as</code> 為有限長的串列，並把 <code class='haskell'>zipWith</code> 視為在其第一個參數之上的歸納定義。</p>若我們試著展開 <code class='haskell'>poly x [a,b,c,d]</code>, 會得到：</p>
%{
%format (quad f) = f"^4"<br>22
<div><pre class='spec'>
   poly x [a,b,c,d]
=  sum (zipWith (*) [a,b,c,d] (iterate (* x) 1))
=    {- 展開 |iterate|, 將「|f|自我組合四次」記為 |quad f| -}
   sum (zipWith (*) [a,b,c,d]
     (1 : (1*x) : (1*x*x) : (1*x*x*x) : map (quad (*x)) (iterate (*x) 1)))
=  a {-"\,"-}+{-"\,"-} b *x {-"\,"-}+{-"\,"-} c * x * x {-"\,"-}+{-"\,"-} d * x * x * x {-"~~."-}
</pre></div>
%}<br>22
<p>可看到式子越長，便累積越多個 <code class='haskell'>(*x)</code>。當 <code class='haskell'>as</code> 長度為 <code class='haskell'>n</code>, 需要的乘法數目為 $O(n^2)$.我們有可能降低做乘法的次數嗎？</p>
<p>我們試著找出 <code class='haskell'>poly</code> 在 <code class='haskell'>as</code> 上的歸納定義。當 <code class='haskell'>as := []</code> 時，<code class='haskell'>poly x []</code> 可歸約為 <code class='haskell'>0</code>.考慮 <code class='haskell'>as := a:as</code> 的情況，和做證明時一樣，我們先將 <code class='haskell'>poly x (a:as)</code> 展開，然後試著整理出 <code class='haskell'>sum (zipWith (*) as (iterate (* x) 1)</code>，以便收回成為 <code class='haskell'>poly x as</code>。計算中的每一步都以此為目的，試著將 <code class='haskell'>sum</code> 與 <code class='haskell'>zipWith</code> 移動至 <code class='haskell'>iterate</code> 旁邊:</p>

<div><pre style='display:none'>
polyDer1 x a as =
</pre></div>
 <div><pre style='display:none'><id='ex:polyDer1'>
      poly x (a : as)
 ===   {- |poly| 的定義 -}
      sum (zipWith (*) (a:as) (iterate (* x) 1))
 ===   {- |iterate| 的定義 -}
      sum (zipWith (*) (a:as) (1 : map (* x) (iterate (* x) 1)))
 ===   {- |zipWith| 與 |sum| 的定義 -}
      a + sum (zipWith (*) as (map (* x) (iterate (* x) 1)))
 ===   {- |zipWith (*) as . map (* x) = map (* x) . zipWith (*) as|，見習題 -}
      a + sum (map (* x) (zipWith (*) as (iterate (* x) 1)))
 ===   {- |sum . map (* x) = (* x) . sum| -}
      a + (sum (zipWith (*) as (iterate (* x) 1))) * x
 ===   {- |poly| 的定義 -}
      a + (poly x as) * x {-"~~."-}
</pre></div>
第 <code class='haskell'>4</code> 步中關於 <code class='haskell'>zipWith</code> 與 <code class='haskell'>map</code> 的性質幫助我們將 <code class='haskell'>map (*x)</code> 往外提、將 <code class='haskell'>zipWith</code> 往裡推。事實上，該性質不限於乘法，而可適用於任何滿足結合律的運算子 <code class='haskell'>otimes</code>。我們可非正式地理解如下：<br>
<div><pre class='spec'>
   zipWith otimes [a,b,c] (map (`otimes` x) [d,e,f])
=  [a `otimes` (d `otimes` x), b `otimes` (e `otimes` x), c `otimes` (f `otimes` x)]
=    {- 結合律: |m `otimes` (n `otimes` k) = (m `otimes` n) `otimes` k| -}
   [(a `otimes` d) `otimes` x, (b `otimes` e) `otimes` x, (c `otimes` f) `otimes` x]
=  map (`otimes` x) (zipWith otimes [a,b,c] [d,e,f]) {-"~~."-}
</pre></div>
第 <code class='haskell'>5</code> 步之中的 <code class='haskell'>sum . map (* x) = (* x) . sum</code> 在習題 ref ex:sum-map-times 中證明過，需要乘法與加法的分配律。在本推導中，它的功能是將 <code class='haskell'>sum</code> 往右推。它也是使 <code class='haskell'>poly</code> 可以加速的關鍵性質：共同的 <code class='haskell'>(*x)</code> 可以提出來 ---左手邊可能做了的許多次 <code class='haskell'>(*x)</code> 其實只需做一次。追根究底，<code class='haskell'>poly</code> 之所以能算得更快，都歸功於乘法與加法的分配律。經過上述計算，我們可得：<br>
<div><pre class='spec'>
poly x []        = 0
poly x (a : as)  = a + (poly as) * x {-"~~."-}
</pre></div>
在這個定義中，函數 <code class='haskell'>poly</code> 遞迴多少次，便做多少個乘法。因此本演算法所需的乘法數目為 $O(n)$.<br>
<p>快速版本的函數 <code class='haskell'>poly</code> 相當於把 $a_0 + a_1 x + a_2 x^2 + ... + a_n x^n$ 轉換成</p>
<div><code class='haskell'>
    a_0 + x \times (a_1 + x \times (a_2 + ... + (a_{n-1} + x \times a_n)))\mbox{~~.}
</code></div>
<p>這條規則在 William George Horner 1819 年的一篇論文中出現並證明，因此通常被稱作 <em>Horner 法則</em> index Horner法則 Horner's rule ，雖然 Horner 本人和許多歷史學家們都相信該規則可被追溯得更早。</p>
% % map f (iterate f x) = iterate f (f x)
% % zipWith (⊗) as . map (⊗X) = map (⊗X) . zipWith (⊗) as, 如果 ⊗ 滿足結合律
% % sum . map (×X) = (×X) . sum, a special case of foldr ⊕ e . map (⊗X) = (⊗X) . foldr ⊕ e, 如果 (a ⊕ b) ⊗ X = (a ⊗ X) ⊕ (b ⊗ X), 且 e ⊗ X = e.
%<br>22
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b><id='ex:zipWith-otimes-map'>
<p>試證明：如果 <code class='haskell'>otimes</code> 滿足結合律，<code class='haskell'>zipWith otimes as . map (`otimes` x) = map (`otimes` x) . zipWith otimes as</code>。</p>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>欲證明<code class='haskell'>zipWith otimes as (map (`otimes` x) bs) = map (`otimes` x) (zipWith otimes as bs)</code>, 在 <code class='haskell'>as</code> 上做歸納。當 <code class='haskell'>as := []</code>, 等號兩邊都歸約成 <code class='haskell'>[]</code>.考慮 <code class='haskell'>as := a:as</code> 的情況。若 <code class='haskell'>bs := []</code>, 等號兩邊仍均為 <code class='haskell'>[]</code>.當 <code class='haskell'>bs := b:bs</code>:</p>

<div><pre style='display:none'>
zipWithOTimesMap :: (a -> a -> a) -> a -> [a] -> a -> a -> [a] -> [a]
zipWithOTimesMap otimes a as x b bs =
</pre></div>
 <div><pre style='display:none'>
      zipWith otimes (a:as) (map (`otimes` x) (b:bs))
 ===    {- |zipWith| 與 |map| 之定義 -}
      (a `otimes` (b `otimes` x)) : zipWith otimes as (map (`otimes` x) bs)
 ===    {- 歸納假設 -}
      (a `otimes` (b `otimes` x)) : map (`otimes` x) (zipWith otimes as bs)
 ===    {- |otimes| 滿足結合律 -}
      ((a `otimes` b) `otimes` x) : map (`otimes` x) (zipWith otimes as bs)
 ===    {- |zipWith| 與 |map| 之定義 -}
      map (`otimes` x) (zipWith otimes (a:as) (b:bs)) {-"~~."-}
</pre></div>
</div>
</div>
<h3 class='subsection' >二進位表示法<id='sec:exp-binary-roll'></h3><p>回顧第 ref sec:induction-on-Nat 節中的函數 <code class='haskell'>exp</code>。該函數計算乘冪 --- $|exp b n| = b^n$，其定義如下:</p>
<div><pre class='spec'>
exp :: Nat -> Nat -> Nat
exp b Zero     = 1
exp b (Suc n)  = b *: exp b n {-"~~."-}
</pre></div>
以這個演算法計算 $b^n$ 時會需要 $O(n)$ 個乘法。是否有更快的做法呢？<br>
%{
%format tt = "\mymathbb{1}"
%format ff = "\mymathbb{0}"<br>22

<div><pre style='display:none'>
tt = True
ff = False

exp2 :: Int -> List Bool -> Int
exp2 b = exp b . decimal
</pre></div>
 <p>我們先定義函數 <code class='haskell'>binary :: Nat -> List Bool</code>，可將一個自然數轉換成<em>反轉</em>的二進位表示法（即最低有效位在左邊，最高有效位在右邊）。以下我們將 <code class='haskell'>False</code> 簡寫為 <code class='haskell'>ff</code>, <code class='haskell'>True</code> 簡寫為 <code class='haskell'>tt</code>：</p>
<div><pre style='display:none'>
binary 0  = []
binary n  | even n  = ff : binary (n `div` 2)
          | odd n   = tt : binary (n `div` 2) {-"~~."-}
</pre></div>
例如，<code class='haskell'>map binary [1,2,3,4] = [[tt], [ff,tt], [tt,tt], [ff,ff,tt]]</code>.函數 <code class='haskell'>binary</code> 在每次遞迴呼叫時將參數減半，因此 <code class='haskell'>binary n</code> 只需要 $O(\log n)$ 的時間。我們讓 <code class='haskell'>binary</code> 傳回反轉的二進位數是為了方便定義 <code class='haskell'>decimal :: List Bool -> Nat</code> --- <code class='haskell'>binary</code> 的反函數，將 <code class='haskell'>binary</code> 的結果轉回成原有的數字：<br>
<div><pre style='display:none'>
decimal []      = 0
decimal (c:cs)  = if c then 1 + 2 * decimal cs else 2 * decimal cs {-"~~."-}
</pre></div>
我們可證明 <code class='haskell'>decimal . binary = id</code>.<br>
<p>回到 <code class='haskell'>exp</code>, 試計算如下</p>
<div><pre class='spec'>
   exp b
=    {- |id| 為 |(.)| 的單位元 -}
   exp b . id
=    {- |decimal . binary = id| -}
   exp b . decimal . binary {-"~~."-}
</pre></div>
由於 <code class='haskell'>binary n</code> 只需 $O(\log n)$ 的時間，如果我們能把 <code class='haskell'>exp b . decimal</code> 的計算時間也縮減到 $O(\log n)$, 我們就有個只需對數時間的演算法了！<br>
<p>令 <code class='haskell'>roll b = exp b . decimal</code>。顯然 <code class='haskell'>roll b [] = 1</code>. 考慮輸入為 <code class='haskell'>c:cs</code> 的情況，在以下的推導中，我們假設 $|exp b n| = b^n$ 擁有乘冪該有的各種算術性質：</p>

<div><pre style='display:none'>
roll b = exp b . decimal

rollDer :: Int -> Bool -> [Bool] -> Int
rollDer b c cs =
</pre></div>
 <div><pre style='display:none'>
    roll b (c:cs)
 ===    {- |exp2| 與 |decimal| 之定義  -}
    exp b (if c then 1 + 2 * decimal cs else 2 * decimal cs)
 ===    {- 函數分配進 |if| -}
    if c then exp b (1 + 2 * decimal cs) else exp b (2 * decimal cs)
 ===    {- 算術：$b^{i + 2 \times x} = b^i \times {(b^x)}^2 $ -}
    if c then b * square (exp b (decimal cs)) else square (exp b (decimal cs))
 ===    {- |roll| 之定義  -}
    if c then b * square (exp2 b cs) else square (roll b cs){-"~~."-}
</pre></div>
因此，我們推導出了在 $O(\log n)$ 時間內計算 $b^n$ 的程式如下：<br>
<div><pre class='spec'>
exp b = roll b . binary

roll b []      = 1
roll b (c:cs)  = if c then b * square (exp2 b cs) else square (exp2 b cs){-"~~."-}
</pre></div>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>如何得知 <code class='haskell'>binary</code> 會終止？它的定義用的是什麼歸納方式？</p>
</div>
<div class = 'Exercise'>
<b>練習:</b>
<p>證明 <code class='haskell'>decimal . binary = id</code>.</p>
</div>
<div class = 'Exercise'>
<b>練習:</b>
<p>展開 <code class='haskell'>exp b = roll b . binary</code> 以導出一個不產生中間串列的 <code class='haskell'>exp</code> 定義。這個定義用的是什麼歸納方式呢？</p>
</div>
<div class = 'Answer'>
<b>答:</b> 
<div><pre style='display:none'>
exp b 0 = 1
exp b n  | even n  = square (exp b (n `div` 2))
         | odd n   = b * square (exp b (n `div` 2)) {-"~~."-}
</pre></div>
由於遞迴呼叫中的 <code class='haskell'>n</code> 總是變小，本定義可視為 <code class='haskell'>n</code> 之上的良基歸納。<br>
</div>
</div>

%} % for tt and ff<br>22
<h3 class='subsection' >小結與提醒</h3><p>如果回顧本節發生了什麼，該說：我們為 <code class='haskell'>poly</code> 和 <code class='haskell'>roll . decimal</code> 找出了歸納定義。它們的效率因此提升了，但這只能說是<em>湊巧</em>：兩個演算中，都有些代數性質可運用，使得推導出的歸納定義在每一步需要做的工作不多，剛好是有效率的。</p>
<p>一般說來，歸納定義和效率提升不見得能畫上等號。導出了某函數的歸納定義後，仍需針對它做分析，才能知道這個推導是否值得。有些情況下，推導出的程式有較好的時間複雜度，這樣的程式<em>通常</em>能表現得比原來的程式好。有些情況下，找出歸納定義能消除中間串列，或著減少走訪資料結構的次數。這時，導出的程式仍有同樣的時間複雜度，但<em>可能</em>有較小的常數。此時需注意：本章談的僅是時間複雜度，而且只考慮一些特定運算元被使用的次數。實際上的執行效率受到許多因素的影響，例如：不同運算元花費不同的時間；空間的使用量也影響效率（例如，使用大量記憶體的程式可能需要較多次垃圾收集）；某些演算法適合快取，等等。我們在之後的章節中將看到一些歸納定義程式走訪資料結構的次數雖較少，但反而執行得慢的例子。</p>
<h3 class='subsection' >掃描引理<id='sec:sum-scan-lemma'></h3><p>在結束本節之前，我們再看一個將在本章後段扮演重要角色的例子。如我們所知，函數 <code class='haskell'>sum :: List Int -> Int</code> 計算一個串列的總和。如果我們想計算一個串列由右到左的<em>累計和</em>，例如當給定串列 <code class='haskell'>[3,7,2,4]</code>，我們希望得到 <code class='haskell'>[16,13,6,4,0]</code>（其中 <code class='haskell'>6 = 2 + 4</code>, <code class='haskell'>13 = 7 + 2 + 4</code>，<code class='haskell'>16 = 3 + 7 + 2 + 4</code>, 而 <code class='haskell'>0</code> 是空串列的和），該怎麼做呢？</p>
<p>在第 ref sec:list-segments 節中，我們曾提及計算一個串列所有<em>後段</em>(<em>suffixes</em>)的函數 <code class='haskell'>tails :: List a -> List (List a)</code>。 index list 串列!suffix 後段 例如，<code class='haskell'>tails [3,7,2,4]</code> 將得到 <code class='haskell'>[[3,7,2,4],</code> <code class='haskell'>[7,2,4],</code> <code class='haskell'>[2,4],</code> <code class='haskell'>[4],</code> <code class='haskell'>[]]</code>。對串列的每一個後段算總和，我們便得到累計和了：</p>
<div><pre style='display:none'>
runsum :: List Int -> List Int
runsum = map sum . tails {-"~~."-}
</pre></div>
由於使用多個 <code class='haskell'>sum</code> 函數走訪每個後段，如此定義出的 <code class='haskell'>runsum</code> 將是一個執行時間為 $O(n^2)$ 的函數。<br>
<p>但讀者想必已覺得可不用如此費事：我們應該可以在由右到左走訪串列的過程中<em>記住目前為止的和</em>，避免重算 <code class='haskell'>sum</code>。事實上，同樣的道理可用在 <code class='haskell'>sum</code> 以外的更多函數上。給定函數 <code class='haskell'>f :: List A -> B</code>, 並假設 <code class='haskell'>f</code> 能寫成如下的形式：</p>
\begin{flalign}
\qquad\quad
\begin{split}
|f []| & |= e|\\
|f (x:xs)|  & |= x `oplus` f xs {-"~~."-}|
\end{split}
\label{eq:f-fold-scan}
\end{flalign}<br>22
<p>函數 <code class='haskell'>sum</code> 是符合  eqref eq:f-fold-scan  的一個特例： <code class='haskell'>e = 0</code>, <code class='haskell'>oplus = (+)</code>.定義 <code class='haskell'>scan = map f . tails</code>, 我們想推導出一個 <code class='haskell'>oplus</code> 的被使用次數與輸入串列長度成正比的 <code class='haskell'>scan</code> 實作。</p>
<p>為方便讀者，我們回顧一下 <code class='haskell'>tails</code> 的定義：</p>
<div><pre class='spec'>
tails []      = [[]]
tails (x:xs)  = (x:xs) : tails xs {-"~~."-}
</pre></div>
據此推導 <code class='haskell'>scan</code>. 顯然 <code class='haskell'>scan [] = [e]</code>. 我們考慮 <code class='haskell'>scan (x:xs)</code> 的情況：<br>

<div><pre style='display:none'>
scanSumLemmaDer1 f oplus x xs =
</pre></div>
 <div><pre style='display:none'>
      map f (tails (x:xs))
 ===    {- |tails| 之定義 -}
      map f ((x:xs) : tails xs)
 ===    {- |map| 與 |f| 之定義 -}
      (x `oplus` f xs) : map f (tails xs) {-"~~."-}
</pre></div>
推演到此，好像只能把上式收回成 <code class='haskell'>(x `oplus` f xs) : scan xs</code> 了，對改進複雜度並沒有什麼幫助。為了增進效率，我們希望申論：<code class='haskell'>f xs</code> 是已經算出了的，不必重複算。此處將用到幾個關鍵性質。首先，對所有 <code class='haskell'>xs</code>, <code class='haskell'>tails xs</code> 的第一個元素永遠是 <code class='haskell'>xs</code>！這可寫成<br>
<div><code class='haskell'><id='eq:head-tails'>
  |head (tails xs)|&|= xs|\mbox{~~.}
</code></div>
<p>有了 eqref eq:head-tails ，直覺上，算出 <code class='haskell'>ys = map f (tails xs)</code> 之後，<code class='haskell'>f xs</code> 的值就是 <code class='haskell'>ys</code> 的第一個元素，不用重複計算了。也就是說， <code class='haskell'>head (map f (tails xs)) = f xs</code>。但要由  eqref eq:head-tails  證明出此性質，我們還需要一個性質允許我們將 <code class='haskell'>head</code> 往右推 ---對所有 <code class='haskell'>f</code>, <code class='haskell'>head . map f = f . head</code>:</p>
<div><pre class='spec'>
      head (map f (tails xs))
 ===    {- 因 |head . map f = f . head| -}
      f (head (tails xs))
 ===    {- 因 \eqref{eq:head-tails} -}
      f xs {-"~~."-}
</pre></div>
<p>現在我們可繼續推導 <code class='haskell'>scan</code>:</p>

<div><pre style='display:none'>
scanSumLemmaDer2 f oplus x xs =
</pre></div>
 <div><pre style='display:none'>
      (x `oplus` f xs) : map f (tails xs) {-"~~."-}
 ===     {- |head (map f (tails xs)) = f xs| -}
      (x `oplus` head (map f (tails xs))) : map f (tails xs)
 ===     {- 抽取出 |map f (tails xs)| -}
      let ys = map f (tails xs)
      in (x `oplus` head ys) : ys {-"~~."-}
</pre></div>
由此我們得到<br>
<div><pre class='spec'>
scan []      =  [e]
scan (x:xs)  =  let  ys = scan xs
                in   (x `oplus` head ys) : ys {-"~~."-}
</pre></div>
給定長度為 <code class='haskell'>n</code> 的串列，歸納定義的 <code class='haskell'>scan</code> 只將 <code class='haskell'>oplus</code> 使用 <code class='haskell'>n</code> 次。當 <code class='haskell'>oplus</code> 只需常數時間，這是一個時間複雜度為 $O(n)$ 的演算法。函數 <code class='haskell'>runsum</code> 則是當 <code class='haskell'>e = 0</code>, <code class='haskell'>oplus = (+)</code> 時的特例。<br>
<p>一個函數 <code class='haskell'>f :: List A -> B</code> 若可寫成  eqref eq:f-fold-scan  的形式，我們說此函數是一個「摺(fold)」. index fold 摺 這是函數語言中相當重要而好用的一個抽象化。我們將在第 ref ch:fold 章中細談關於摺的種種。當 <code class='haskell'>f</code> 是一個摺時，<code class='haskell'>map f . tails</code> 這樣的函數習慣上稱作一個「掃描(scan)」。這是本節標題的由來。關於掃描、摺、與掃描引理，我們將在第 ref sec:scan-lemma 節中做更完整的介紹。</p>
<h2 class='section' >變數換常數</h2><p>接下來的幾節中，我們將介紹幾種常見的程式推導技巧。\todo{generalize}</p>
<p>本節先以一個簡單但時常用上的技巧作為開頭。回顧在例  ref ex:positions  中提及的函數 <code class='haskell'>positions</code>:</p>
<div><pre class='spec'>
positions z = map fst . filter ((==z) . snd) . zip [Zero..] {-"~~."-}
</pre></div>
<code class='haskell'>positions z xs</code> 傳回 <code class='haskell'>z</code> 在 <code class='haskell'>xs</code> 中出現的所有位置。上述的定義方式會產生許多中間串列。我們能用第  ref sec:fold-unfold-transform  節中的方式，利用展開-收回轉換為 <code class='haskell'>positions</code> 推導出一個歸納定義，並藉此將中間串列消除嗎？<br>
<p>我們針對 <code class='haskell'>positions z</code> 的輸入做分析，在歸納狀況中，先將 <code class='haskell'>positions z (x:xs)</code> 展開，希望最後能收回 <code class='haskell'>positions z xs</code>.由於讀者對相關計算應已熟悉，以下的演算以較快的步調進行：</p>

<div><pre style='display:none'>
positionsDer1 ::Eq a => a -> a -> List a -> List Nat
positionsDer1 z x xs =
</pre></div>
 <div><pre style='display:none'>
      positions z (x:xs)
 ===  map fst . filter ((==z) . snd) . zip [Zero .. ] $ (x:xs)
 ===    {- |zip| 之定義， |[0..] = 0 : [1..]| -}
      map fst . filter ((==z) . snd) $ (Zero,x) : zip [1..] (x:xs)
 ===    {- |map| 與 |filter| 之定義 -}
      if x==z then Zero : map fst (filter ((==z) . snd) (zip [1..] (x:xs)))
         else map fst (filter ((==z) . snd) (zip [1..] (x:xs))) {-"~~."-}
</pre></div>
結果我們卡在這兒了：最後的式子中，<code class='haskell'>zip</code> 的參數是 <code class='haskell'>[1..]</code>, 但 <code class='haskell'>positions</code> 的定義要求這個參數得是 <code class='haskell'>[Zero ..]</code>. 我們無法將式子收回得到 <code class='haskell'>positions z xs</code>.<br>
<p>看來，問題是 <code class='haskell'>positions</code> 的定義把 <code class='haskell'>Zero</code> 給寫死了。如果我們索性把該位置變成一個變數呢？我們定義：</p>
<div><pre style='display:none'>
posFrom z i = map fst . filter ((z==) . snd) . zip [i..]
</pre></div>
函數 <code class='haskell'>positions</code> 是 <code class='haskell'>posFrom</code> 的特例：<code class='haskell'>positions z = posFrom z 0</code>.而 <code class='haskell'>posFrom</code> 的歸納定義可用展開-收回轉換找出：<br>

<div><pre style='display:none'>
posFromDer1 :: Eq a => a -> Nat -> a -> List a -> List Nat
posFromDer1 z i x xs =
</pre></div>
 <div><pre style='display:none'>
      posFrom z i (x:xs)
 ===  map fst . filter ((==z) . snd) . zip [i..] $ (x:xs)
 ===    {- |zip| 之定義， |[i..] = i : [Suc i..]| -}
      map fst . filter ((==z) . snd) $ (i,x) : zip [Suc i..] (x:xs)
 ===    {- |map| 與 |filter| 之定義 -}
      if x==z then i : map fst (filter ((==z) . snd) (zip [Suc i..] (x:xs)))
         else map fst (filter ((==z) . snd) (zip [Suc i..] (x:xs)))
 ===    {- |posFrom| 之定義 -}
      if x==z then i : posFrom z (Suc i) xs
         else posFrom z (Suc i) xs {-"~~."-}
</pre></div>
由此我們可得：<br>
<div><pre class='spec'>
posFrom z i []      =  []
posFrom z i (x:xs)  =  if x==z then i : posFrom z (1+i) xs
                         else posFrom z (1+i) xs {-"~~."-}
</pre></div>
<p>由於將一個常數換成變數，<code class='haskell'>posFrom</code> 比 <code class='haskell'>positions</code> 多了些彈性，因此較容易收回。這個技巧在許多場合用得上，往往是許多程式推導的第一步。但我並不建議大家看到任一個定義，便一股腦地把所有常數都換成變數。如同第 ref sec:using-hints-from-symbols 節中提及的原則，該把哪些常數換掉仍應由計算中發現，只用在必要之處。</p>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>函數 <code class='haskell'>index</code> 為串列中的每個元素標上位置。</p>
<div><pre style='display:none'>
index :: List a -> List (Nat :* a)
index = zip [Zero .. ] {-"~~."-}
</pre></div>
請試著為 <code class='haskell'>index</code> 導出一個歸納定義。如果不成功，找出一個更通用的輔助函數，並導出其歸納定義。<br>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>試著展開-收回 <code class='haskell'>index (x:xs)</code>：</p>
<div><pre class='spec'>
     index (x:xs)
 === zip [Zero .. ] (x:xs)
 ===  {- |[Zero ..] = Zero: [1 ..]|, |zip| 之定義 -}
     (Zero,x) : zip [1..] xs {-"~~."-}
</pre></div>
我們又發現 zip [1..] 無法收回成 index xs.因此，我們定義：<br>
<div><pre style='display:none'>
indexFrom :: Nat -> List a -> List (Nat :* a)
indexFrom i = zip [i..] {-"~~."-}
</pre></div>
試著推導 <code class='haskell'>indexFrom</code> 的歸納定義如下：<br>
<div><pre class='spec'>
     indexFrom i (x:xs)
 === zip [i .. ] (x:xs)
 ===  {- |[i ..] = i: [Suc i ..]|, |zip| 之定義 -}
     (i,x) : zip [Suc i..] xs
 === (i,x) : indexFrom (Suc i) xs {-"~~."-}
</pre></div>
因此我們已得到：<br>
<div><pre class='spec'>
indexFrom i []      = []
indexFrom i (x:xs)  = i,x) : indexFrom (Suc i) xs {-"~~."-}
</pre></div>
</div>
</div>
<h2 class='section' >組對<id='sec:tupling'></h2><p>接下來我們介紹另一個重要的技巧：「組對(tupling)」。</p>
<h3 class='subsection' >陡串列<id='sec:steep'></h3><p>給定一個整數串列。當我們說它很「陡」，意思是它由左到右下降得極快，快到每一個元素都大於其右邊所有元素的和。形式化的定義如下：</p>
<div><pre style='display:none'>
steep :: List Int -> Bool
steep []      = True
steep (x:xs)  = x > sum xs && steep xs {-"~~."-}
</pre></div>
如果當作一個程式，當輸入串列長度為 <code class='haskell'>n</code>, 由於反覆呼叫 <code class='haskell'>sum</code>, 上述的程式需要 $O(n^2)$ 的時間。但每次算出的 <code class='haskell'>sum xs</code> 和 <code class='haskell'>x</code> 比較後便立刻被丟棄，似乎很浪費。我們能否把 <code class='haskell'>sum</code> 的結果存下來呢？下述函數 <code class='haskell'>steepsum</code> 把 <code class='haskell'>steep</code> 與 <code class='haskell'>sum</code> 都算出來，放在一個序對中：<br>
<div><pre class='spec'>
steepsum :: List Int -> (Bool :* Int)
steepsum xs = (steep xs, sum xs) {-"~~."-}
</pre></div>
我們看看 <code class='haskell'>steepsum</code> 能否算得快一點？<br>
<p>根據定義，<code class='haskell'>steepsum [] = (True, 0)</code>. 我們看看 <code class='haskell'>xs = x:xs</code> 的例子：</p>

<div><pre style='display:none'>
steepsumDer1 :: Int -> List Int -> (Bool :* Int)
steepsumDer1 x xs =
</pre></div>
 <div><pre style='display:none'>
      steepsum (x:xs)
 ===    {- |steepsum| 之定義 -}
      (steep (x:xs), sum (x:xs))
 ===    {- |steep| 與 |sum| 之定義 -}
      (x > sum xs && steep xs, x + sum xs)
 ===    {- 將子算式提取至 |let| 中 -}
      let (b, s) = (steep xs, sum xs)
      in (x > s && b, x + s)
 ===    {- |steepsum| 之定義 -}
      let (b, s) = steepsum xs
      in (x > s && b, x + s) {-"~~."-}
</pre></div>
我們已推導出：<br>
<div><pre style='display:none'>
steepsum []      =  (True, 0)
steepsum (x:xs)  =  let (b, s) = steepsum xs
                    in (x > s && b, x + s) {-"~~."-}
</pre></div>
這是一個只用 $O(n)$ 時間的程式。有了 <code class='haskell'>steepsum</code>，我們可重新定義 <code class='haskell'>steep</code> 為 <code class='haskell'>steep = fst . steepsum</code>。<br>
<p>讓一個函數<em>多傳回一些值</em>的動作稱作<em>組對</em>(<em>tupling</em>) --- 因為多傳回的值被放在一個序對中。 index tupling 組對 <p class='footer'>在一些函數語言中，<code>pair'' 指含兩個成員的序對，<code>tuple'' 則不限定為兩個成員。Tuple 也可當作動詞，指做出一個 tuple. 本書將動詞的 tuple 譯為「組對」-- 組出一個對。有些語言中 pair 與 tuple 有更根本的差異，但本書中不做區分。</p>我們常用此技巧來存下可重複使用的中間值，並減少走訪資料結構的次數。</p>
<p>最後一提：若使用第 ref sec:pairs 節， pageref par:split-product 頁介紹的「分裂」運算元： index pair 序對!split 分裂 </p>
<div><pre class='spec'>
fork :: (a -> b) -> (a -> c) -> a -> (b :* c)
(fork f g) x = (f x, g x) {-"~~."-}
</pre></div>
函數 <code class='haskell'>steepsum</code> 的定義可較簡潔地寫成：<br>
<div><pre class='spec'>
steepsum = fork steep sum {-"~~."-}
</pre></div>
本書將在適當時採用這種寫法。<br>
責任越大，能力越強？ 某個意義上，函數 <code class='haskell'>steepsum</code> 做的事比 <code class='haskell'>steep</code> 多：後者只判斷輸入是否為陡串列，前者不只如此，還多附送了串列的和。然而，傳回比較多東西、似乎做了更多事的程式，反倒可以執行得比較快。竟出現「責任越大，能力越強」這種違反直覺的現象，這是怎麼回事呢？%<p class='footer'>「能力越強，責任越大 (with great power comes great responsibility)」是 2002 年版《蜘蛛人》電影的名句。根據考證\citep{OToole:15:Great}, 法國國民公會1793年的政令中即出現過類似的想法，包括邱吉爾和羅斯福等人也都說過類似話語的不同版本。</p><br>
<p>其實，在歸納定義與歸納證明中，這都是常見的。有些比較通用的程式反倒比較容易定義；有些定理本身不好證明，為了證明它，我們把它變得更廣泛、更強些，反倒好證了。箇中原因說穿了便不難理解，函數 <code class='haskell'>steepsum</code> 便是一個容易明白的好例子：一個函數若傳回比較多資訊，在遞迴呼叫它時，我們便有更多資訊可直接取用。同樣地，一個定理若保證更強的性質，表示在使用歸納假設的步驟中，我們有了更強的性質可用。</p>
<p>如果我們把一個函數或待證的定理擴充得太強，確實也有可能使它們強到寫不出來、證不出來。做歸納定義或證明的重要技巧之一，便是找到這麼一個平衡點：將一個待定義或證明的物件擴充到足以提供歸納步驟需要的所有資訊，又不至於強到無法寫出、證出。</p>
<p>在這一節以及下一節中，我們都會看到許多如此的例子。</p>
<h3 class='subsection' >以串列標記樹狀結構</h3><p>我們再舉一個組對的好例子。回顧第  ref sec:user-defined-data 與 ref sec:other-inductive-datatypes 節中提及的外標籤二元樹：</p>
<div><pre class='spec'>
data ETree a  = Tip a | Bin (ETree a) (ETree a) {-"~~."-}
</pre></div>
下述函數 <code class='haskell'>size :: ETree a -> Int</code> 計算一棵樹中標籤的數目（對 <code class='haskell'>ETree</code> 而言是 <code class='haskell'>Tip</code> 出現的次數）； <code class='haskell'>repl t xs</code> 則將 <code class='haskell'>t</code> 原有的標籤丟棄，改用串列 <code class='haskell'>xs</code> 由右至左依序重新為 <code class='haskell'>t</code> 上標籤。觀察：在遞迴呼叫中，我們用 <code class='haskell'>take</code> 和 <code class='haskell'>drop</code> 將串列 <code class='haskell'>xs</code> 截成適當的長度：<br>
<div><pre style='display:none'>
size (Tip _)    = 1
size (Bin t u)  = size t + size u {-"~~,"-}

repl :: ETree a -> List b -> ETree b
repl (Tip _)    xs = Tip (head xs)
repl (Bin t u)  xs = Bin (repl t (take n xs)) (repl u (drop n xs))
    where n = size t {-"~~."-}
</pre></div>
如果 <code class='haskell'>t</code> 是一個向左傾斜的二元樹，<code class='haskell'>repl t xs</code> 不僅會反覆計算 <code class='haskell'>size</code>，也會反覆地將 <code class='haskell'>take</code> 與 <code class='haskell'>drop</code> 用在 <code class='haskell'>xs</code> 上，使得上述的 <code class='haskell'>repl</code> 成為一個 $O(n^2)$ 的演算法。利用組對的技巧，我們能讓 <code class='haskell'>repl</code> 的時間複雜度小一些嗎？<br>
%{
%format n1
%format n2<br>22
<p>我們試著把 <code class='haskell'>repl</code> 作用在一個稍微左斜的樹，<code class='haskell'>(Bin (Bin t u) v)</code> 之上，看看有什麼能做的。令 <code class='haskell'>t</code>, <code class='haskell'>u</code> 的 <code class='haskell'>size</code> 分別為 <code class='haskell'>n1</code> 與 <code class='haskell'>n2</code>.如果我們希望導出一個線性時間的程式，其中一個提示是：我們希望在 <code class='haskell'>repl (Bin (Bin t u) v) xs</code> 中，<em><code class='haskell'>xs</code> 的每個元素最多都只被 <code class='haskell'>take</code> 和 <code class='haskell'>drop</code> 各碰過一次</em>。依此原則，以下的推導基嘗試做到兩點：首先，把連續的 <code class='haskell'>take</code> 消去；其次，若已做了 <code class='haskell'>take n1 xs</code>，就避免再出現 <code class='haskell'>take (n1 + n2) xs</code>，因為後者的存在會讓 <code class='haskell'>take</code> 重複處理 <code class='haskell'>xs</code> 中的元素。我們會用到習題  ref ex:take-take  --  ref ex:drop-drop  中提到的三個性質：</p>
<div><code class='haskell'>
|take m (take (m+n) xs)| ~&=~ |take m xs|
\mbox{~~,}\\
|drop m (take (m +: n) xs)| ~&=~ |take n (drop m xs)|\mbox{~~,}\\
|drop (m +: n) xs| ~&=~ |drop n (drop m xs)| \mbox{~~.}
</code></div>
<p>其中 <code class='haskell'>m</code>, <code class='haskell'>n</code> 均為自然數。試演算如下：</p>

<div><pre style='display:none'>
replTrial t u v xs =
</pre></div>
 <div><pre style='display:none'>
      repl (Bin (Bin t u) v) xs
 ===    {- |repl| 之定義，兩次 -}
      Bin  (Bin  (repl t (take n1 (take (n1+n2) xs)))
                 (repl u (drop n1 (take (n1+n2) xs))))
           (repl v (drop (n1+n2) xs))
 ===    {- 習題 \ref{ex:take-take} -- \ref{ex:drop-drop} -}
      Bin  (Bin  (repl t (take n1 xs))
                 (repl u (take n2 (drop n1 xs))))
           (repl v (drop n2 (drop n1 xs)))  {-"~~."-}
</pre></div>

<div><pre style='display:none'>
 where (n1, n2) = (size t, size u)
</pre></div>
 <p>演算到此，與 <code class='haskell'>t</code> 有關的是 <code class='haskell'>repl t</code>, <code class='haskell'>take (size t)</code>, 與 <code class='haskell'>drop (size t)</code> 三項；與 <code class='haskell'>u</code> 有關的是 <code class='haskell'>repl u</code>, <code class='haskell'>take (size u)</code>, 與 <code class='haskell'>drop (size u)</code> 三項。如果我們把 <code class='haskell'>repl t</code>, <code class='haskell'>take (size t)</code>, 與 <code class='haskell'>drop (size t)</code> 取出，當作一個函數之內完成的動作：</p>
<div><pre style='display:none'>
repTail :: ETree a -> List b -> (ETree b :* List b)
repTail s xs = (repl s (take n xs), drop n xs) {-"~~,"-}
  where n = size s {-"~~."-}
</pre></div>
那麼 <code class='haskell'>Bin (repl t (take n1 xs)) (repl u (take n2 (drop n1 xs)))</code> 似乎有可能收回成為這樣的式子：<code class='haskell'>xs</code> 先被丟給 <code class='haskell'>repTail t</code>，將 <code class='haskell'>t</code> 標記好，並得到剩下的串列 <code class='haskell'>drop n1 xs</code>。這個剩下的串列又可以丟給 <code class='haskell'>repTail u</code>, 兩者都只把 <code class='haskell'>xs</code> 走過一次。我們試著導出 <code class='haskell'>repTail</code> 的歸納定義。基底狀況 <code class='haskell'>s := Tip y</code> 比較容易，我們考慮 <code class='haskell'>s := Bin t u</code> 的情況，並演算如下（令 <code class='haskell'>n1 = size t</code>，<code class='haskell'>n2 = size u</code>, 因此 <code class='haskell'>size (Bin t u)= n1 + n2</code>）：<br>

<div><pre style='display:none'>
repTailDer1 :: ETree a -> ETree a -> List b -> (ETree b, List b)
repTailDer1 t u xs =
</pre></div>
 <div><pre style='display:none'>
      repTail (Bin t u) xs
 ===   {- |repTail| 之定義 -}
      (repl (Bin t u) (take (n1 + n2) xs), drop (n1 + n2) xs)
 ===   {- |repl| 之定義，令 |n1 = size t| -}
      (Bin  (repl t (take n1 (take (n1 + n2) xs)))
            (repl u (drop n1 (take (n1 + n2) xs))), drop (n1 + n2) xs)
 ===   {- 習題 \ref{ex:take-take} -- \ref{ex:drop-drop} -}
      (Bin  (repl t (take n1 xs))
            (repl u (take n2 (drop n1 xs))), drop n2 (drop n1 xs))
 ===   {- 提出共同項 -}
      let  (t', xs')   = (repl t (take n1 xs),  drop n1 xs)
           (u', xs'')  = (repl u (take n2 xs'), drop n2 xs')
      in (Bin t' u', xs'')
 ===   {- |repTail| 之定義 -}
      let  (t', xs')   = repTail t xs
           (u', xs'')  = repTail u xs'
      in (Bin t' u', xs'') {-"~~."-}
</pre></div>

<div><pre style='display:none'>
  where n = size (Bin t u)
        (n1, n2) = (size t, size u)
</pre></div>
 %} % format n1 and n2<br>22
<p>因此我們得到：</p>
<div><pre class='spec'>
repTail (Tip _)    xs =  (Tip (head xs), tail xs)
repTail (Bin t u)  xs =  let  (t', xs')   = repTail t xs
                              (u', xs'')  = repTail u xs'
                         in (Bin t' u', xs'') {-"~~."-}
</pre></div>
確實如同所預期的，串列 <code class='haskell'>xs</code> 被 <code class='haskell'>repTail t</code> 使用，得到標籤過的新樹 <code class='haskell'>t'</code>, 和剩下的串列 <code class='haskell'>xs'</code>. 後者再被 <code class='haskell'>repTail u</code> 用來給 <code class='haskell'>u</code> 上標籤。最後我們得傳回剩下的串列 <code class='haskell'>xs''</code>. 實際上把串列變短的動作發生在基底狀況 <code class='haskell'>repTail (Tip _)</code> 中。串列中的每個元素只會在每次遇見 <code class='haskell'>Tip</code> 時被取出一次，因此這是一個線性時間的演算法。<br>
<p>\todo{<code class='haskell'>repsort t = rep t (sort (leaves t []))</code>.}</p>
<p> citet BurstallDarlington:77:Transformation </p>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>回顧第  ref sec:user-defined-data  節中談到的 <code class='haskell'>ITree</code>:</p>
<div><pre class='spec'>
data ITree a = Null | Node a (ITree a) (ITree a) {-"~~."-}
</pre></div>
<em>猴麵包樹(baobab)</em>，又稱猢猻木，是一種樹幹相當粗的樹。%<p class='footer'>猴麵包樹原產於馬達加斯加、非洲等地，也被寫進了《小王子》之中。</p>如果一個 <code class='haskell'>ITree Int</code> 的<em>每個</em>標籤都大於其兩個子樹的標籤總和，我們便說它是一棵猴麵包樹。以下的函數判定一棵樹是否為猴麵包樹（其中 <code class='haskell'>sumT :: ITree Int -> Int</code> 計算一個樹中所有標籤的總和）：<br>
<div><pre style='display:none'>
baobab :: ITree Int -> Bool
baobab Null          =  True
baobab (Node x t u)  =  baobab t && baobab u &&
                          x > (sumT t + sumT u) {-"~~."-}
</pre></div>
因反覆呼叫 <code class='haskell'>sumT</code>, 當樹的大小為 <code class='haskell'>n</code> 時，<code class='haskell'>baobab</code> 的執行時間為 $O(n^2)$.請使用組對的技巧，在 $O(n)$ 的時間內算出 <code class='haskell'>baobab</code>.<br>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>考慮如下的定義：</p>
<div><pre class='spec'>
baosum :: Tree Int -> (Bool, Int)
baosum = fork baobab sumT {-"~~."-}
</pre></div>
如果 <code class='haskell'>baosum</code> 有時間效率為 $O(n)$ 的定義，我們可重定義 <code class='haskell'>baobab = fst . baosum</code>.當 <code class='haskell'>t := Null</code>, 我們有 <code class='haskell'>baosum Null = (True, 0)</code>.考慮 <code class='haskell'>t := Node x t u</code>:<br>

<div><pre style='display:none'>
sumT :: ITree Int -> Int
sumT = error ""

baosumDerInd :: Int -> ITree Int -> ITree Int -> (Bool, Int)
baosumDerInd x t u =
</pre></div>
 <div><pre style='display:none'>
     baosum (Node x t u)
 ===    {- |baosum| 之定義 -}
     (baobab (Node x t u), sumT (Node x t u))
 ===    {- |baobab| 與 |sumT| 之定義 -}
     (  baobab t && baobab u && x > (sumT t + sumT u),
        x + sumT t + sumT u)
 ===    {- 引入區域變數 -}
     let  (b,y) = (baobab t, sumT t)
          (c,z) = (baobab u, sumT u)
     in (b && c && x > (y + z), x + y + z)
 ===    {- |baosum| 之定義 -}
     let  (b,y) = baosum t
          (c,z) = baosum u
     in (b && c && x > (y + z), x + y + z) {-"~~."-}
</pre></div>
如此，我們已經導出：<br>
<div><pre style='display:none'>
baosum Null          = (True, 0)
baosum (Node x t u)  =
  let  (b,y) = baosum t
       (c,z) = baosum u
  in (b && c && x > (y + z), x + y + z) {-"~~."-}
</pre></div>
</div>
</div>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b><id='ex:deepest'>
<p>本題出自 citet HuIwasaki:97:Tupling 。函數 <code class='haskell'>depth</code> 定義一棵 <code class='haskell'>ETree</code> 的<em>深度</em>。<code class='haskell'>Tip</code> 的深度為零，<code class='haskell'>Bin</code> 的深度則為兩子樹中較深者的深度加一：</p>
<div><pre style='display:none'>
depth :: ETree a -> Nat
depth (Tip _)    = Zero
depth (Bin t u)  = Suc (depth t `max` depth u) {-"~~."-}
</pre></div>
下列函數 <code class='haskell'>deepest</code> 則傳回一棵樹中最深的標籤：<br>
<div><pre style='display:none'>
deepest :: ETree a -> List a
deepest (Tip x)    = [x]
deepest (Bin t u)  | m <  n  = deepest u
                   | m == n  = deepest t ++ deepest u
                   | m >  n  = deepest t
    where (m,n) = (depth t, depth u) {-"~~."-}
</pre></div>
請用組對的技巧，避免重複計算 <code class='haskell'>depth</code>.<b>注意</b>: 完成的程式中，<code class='haskell'>(++)</code> 仍可能需要 $O(n^2)$ 的時間。我們將在習題 ref ex:deepestAux 處理這個問題。<br>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>定義：</p>
<div><pre class='spec'>
dd :: ETree a -> (List a, Nat)
dd = fork deepest depth {-"~~."-}
</pre></div>
顯然 <code class='haskell'>dd (Tip x) = ([x], 0)</code>.以下我們考慮歸納情況時，用一個非標準的語法同時處理守衛算式的三個式子：<br>
<div><pre class='spec'>
      dd (Bin t u)
 ===   {- |dd|, |deepest|, 與 |depth| 之定義 -}
      (  ( m <  n  -> deepest u
         | m == n  -> deepest t ++ deepest u
         | m >  n  -> deepest t), 1 + (m `max` n))
      where (m,n) = (depth t, depth u)
 ===   {- 取出 |deepest t| 與 |deepest u| -}
      (  ( m <  n  -> ys
         | m == n  -> xs ++ ys
         | m >  n  -> xs), 1 + (m `max` n))
      where ((xs,m),(ys,n)) = ((deepest t,depth t), (deepest u, depth u))
 ===   {- |dd| 之定義，函數分配進條件判斷 -}
      ( m <  n  -> (ys, 1 + n)
      | m == n  -> (xs ++ ys, 1 + n)
      | m >  n  -> (xs, 1 + m))
      where ((xs,m),(ys,n)) = (dd t, dd u) {-"~~."-}
</pre></div>
因此我們得到：<br>
<div><pre style='display:none'>
dd (Tip x)    = ([x],0)
dd (Bin t u)  | m <  n  = (ys, 1 + n)
              | m == n  = (xs ++ ys, 1 + n)
              | m >  n  = (xs, 1 + m) {-"~~,"-}
  where ((xs,m),(ys,n)) = (dd t, dd u) {-"~~."-}
</pre></div>
</div>
</div>
<h3 class='subsection' >代換為最小標籤 --- 循環程式</h3><p>下列函數 <code class='haskell'>minE</code> 曾出現在第  ref sec:other-inductive-datatypes  節中，找出一棵 <code class='haskell'>ETree</code> 中最小的值。函數 <code class='haskell'>rep</code> 則可視為 <code class='haskell'>repl</code> 的簡單版，將樹中的每個標籤都代換成同一個值 <code class='haskell'>y</code>。</p>
<table>
<tr>
0.45\textwidth<td>
<div><pre style='display:none'>
minE :: ETree Int -> Int
minE (Tip x)    = x
minE (Bin t u)  = minE t `min` minE u {-"~~,"-}
</pre></div>
</td>
</tr>
<tr>
0.5\textwidth<td>
<div><pre style='display:none'>
rep :: b -> ETree a -> ETree b
rep y (Tip _)   = Tip y
rep y (Bin t u) = Bin (rep y t) (rep y u) {-"~~."-}
</pre></div>
</td>
</tr>
</table>
<p>給一棵樹 <code class='haskell'>t</code>, 我們要把 <code class='haskell'>t</code> 之中的每個標籤都代換成 <code class='haskell'>t</code> 的最小標籤。直觀的做法是寫成 <code class='haskell'>let m = minE t in rep t m</code>.如此一來，<code class='haskell'>t</code> 會被走訪兩次，第一次被<code class='haskell'>minE</code> 走訪以計算 <code class='haskell'>m</code>, 第二次由 <code class='haskell'>rep</code> 進行代換。 citet Bird:84:Circular  提出挑戰：有可能在只把 <code class='haskell'>t</code> 走訪一次的情況下，完成上述工作嗎？</p>
<p>以下函數 <code class='haskell'>repmin</code> 同時傳回代換過後的樹，以及原樹中的最小標籤：</p>
<div><pre class='spec'>
repmin :: ETree Int -> a -> (ETree a :* Int)
repmin y = fork (rep y) minE {-"~~."-}
</pre></div>
使用本節的技巧，讀者們應該已經可以為 <code class='haskell'>repmin</code> 導出如下的歸納定義：<br>
<div><pre style='display:none'>
repmin y (Tip x)    =  (Tip y, x)
repmin y (Bin t u)  =  let  (t', m) = repmin y t
                            (u', n) = repmin y u
                       in (Bin t' u', m `min` n) {-"~~."-}
</pre></div>
該定義只將 <code class='haskell'>t</code> 走訪一次。然後我們定義：<br>
<div><pre style='display:none'>
transform :: ETree Int -> ETree Int
transform t =  let (t', m) = repmin m t in t' {-"~~."-}
</pre></div>
函數 <code class='haskell'>transform</code> 用 <code class='haskell'>repmin</code> 算出 <code class='haskell'>t</code> 的最小標籤 <code class='haskell'>m</code>, 同時又用 <code class='haskell'>m</code> 來標記 <code class='haskell'>t</code>... 於是，似乎確實用一次走訪就完成了兩件事！這是怎麼做到的呢？<br>
<p>函數 <code class='haskell'>transform</code> 有個特殊之處：變數 <code class='haskell'>m</code> 既是 <code class='haskell'>repmin</code> 的傳回值，又是其參數。這是一個<em>循環程式</em>(<em>circular program</em>)。 index circular program 循環程式 這樣的程式之所以能正常終止，有賴於 Haskell 的範式順序/惰性求值（見第 pageref para:lazy-evaluation 頁）。實際上發生的事情如此：假設輸入為</p>
<div><pre style='display:none'>
t = Bin  (Bin (Tip 4) (Tip 2))
         (Bin (Bin (Tip 3) (Tip 1)) (Tip 5))
</pre></div>
<code class='haskell'>repmin</code> 將輸入 <code class='haskell'>t</code> 走訪一遍，邊走邊建立了一個未算出的算式 <code class='haskell'>(4 `min` 2) `min` ((3 `min` 1) `min` 5)</code>.該算式就是 <code class='haskell'>m</code> 的值，其實也可視作一棵樹，其結構和 <code class='haskell'>t</code> 一樣，只是把每個 <code class='haskell'>Bin</code> 代換成 <code class='haskell'>min</code>.函數 <code class='haskell'>repmin</code> 的另一項工作是新建一棵樹 <code class='haskell'>t'</code>，該樹之中每個 <code class='haskell'>Tip</code> 的標籤都指到這個算式。根據範式順序求值，這個算式還不用立刻被算出來。直到我們終於不得不算出它，例如當 <code class='haskell'>t'</code> 被傳回，我們要求電腦把 <code class='haskell'>t'</code> 印出來，或著有別的函數需檢查 <code class='haskell'>t'</code> 中的標籤時，該算式才被歸約成一個數字 --- 這需要把該算式走訪一遍。（但，根據惰性求值，一但 <code class='haskell'>m</code> 被算成一個數字，下次使用 <code class='haskell'>m</code> 時就不再需要反覆計算了。）<br>
<p>需注意，雖然「<code class='haskell'>t</code>只被走訪一次」確實成立，這並不表示 <code class='haskell'>transform</code> 必然比老實將樹走訪兩次的程式快 --- 效率是個複雜的問題，本章將陸續談到更多。我的建議是：循環程式應視為有趣、優雅的謎題，而不是以效率為目的的程式設計技巧。</p>
<h3 class='subsection' >小結與提醒<id='sec:tupling-conclude'></h3><p>「組對」的技巧讓函數多傳回一些值。我們可能藉此省下一些重複的計算，增進效率。</p>
<p>我們自然想問：給一個有重複計算、待改進的函數 <code class='haskell'>f</code>, 怎知道該讓它多傳回什麼值？在本節的例子中，我們可由符號演算看出一些端倪：將 <code class='haskell'>f</code> 的定義展開，辨識出被重複計算的子算式，這些子算式就可能用來與原函數組對。但廣泛說來，「將一個函數或性質通用化」是編程與證明中最困難、最需要經驗、智慧的一步。只要找到正確的通用化，例如 <code class='haskell'>steepsum</code> 或 <code class='haskell'>repTail</code>, 剩下的推導都可相當機械化地進行。唯有「通用化」這一步，我們無法保證有任何機械化、公式化的方法可作為解決所有問題的萬靈丹 ---否則編程就是一件可完全自動化的事情了。</p>
<p>雖然如此，我們仍希望基於符號演算的形式方法能給我們一定程度的幫助與指引。程式語言研究的目標之一便是分辨出編程的過程中，哪些部分是瑣碎、機械化的，哪些部分是真正需要靈感與智慧的，並且盡量使用符號幫助，使我們在進行思考時有更多工具。</p>
<p>組對可用於減少走訪資料結構的次數，但這麼做並不見得有效率上的好處。例如，以下函數計算一個串列中元素的平均值：</p>
<div><pre class='spec'>
average xs = sum xs / length xs {-"~~."-}
</pre></div>
利用組對，我們可以另定義一個函數 <code class='haskell'>sumlen = fork sum length</code>,並推導其歸納定義，在一次走訪中同時計算串列的和與長度：<br>
<div><pre style='display:none'>
sumlen []      =  (0,0)
sumlen (x:xs)  =  let (s,l) = sumlen xs
                  in (x + s, 1 + l) {-"~~."-}
</pre></div>
然後平均便可定義成 <code class='haskell'>average' xs = let (s,l) = sumlen xs in s/l</code>.<br>
%函數 |average| 中，串列 |xs| 需要留在記憶體中的時間較長：|sum xs| 計算過後，|xs| 不能立刻被丟掉，而必須留在記憶體中，等著計算 |length xs|.
%而 |average'| 只走訪 |xs'| 一次，|xs| 可以邊走訪邊丟棄。
%\todo{Shall we mention this? Shall we run some experiments?}<br>22
<p>然而，根據 citet HuIwasaki:97:Tupling ，<code class='haskell'>average'</code> 通常比 <code class='haskell'>average</code> 慢。兩者都是 $O(n)$ 的演算法。函數 <code class='haskell'>sumlen</code> 在傳回值時會產生一個序對，該序對立刻被上層拆掉。因此 <code class='haskell'>average'</code> 每處理一個元素耗費的時間較多，往往不如乾脆將 <code class='haskell'>xs</code> 走訪兩次。 citet HuIwasaki:97:Tupling  認為需有更有效率的序對實作法，組對才是值得做的轉換。</p>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>函數 <code class='haskell'>allpairs</code> 傳回輸入串列中任兩個元素（依其原本順序）形成的序對。例如 <code class='haskell'>allpairs [1,2,3,4]</code> 可得到 <code class='haskell'>[(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]</code>。</p>
<div><pre style='display:none'>
allpairs :: List a -> List (a :* a)
allpairs []      = []
allpairs (x:xs)  = map (\y -> (x,y)) xs ++ allpairs xs {-"~~."-}
</pre></div>
而 <code class='haskell'>maxdiff</code> 則計算一個串列中任兩元素前者與後者的最大差：<br>
<div><pre style='display:none'>
maxdiff :: List Int -> Int
maxdiff = maximum . map (\(x,y) -> x - y) . allpairs {-"~~."-}
</pre></div>
當輸入串列長度為 <code class='haskell'>n</code>, 如此定義的 <code class='haskell'>maxdiff</code> 是一個需時 $O(n^2)$ 的演算法。定義：<br>
<div><pre class='spec'>
 mdm xs = (maxdiff xs, ???) {-"~~."-}
</pre></div>
找出 <code class='haskell'>???</code> 可能的值，使得 <code class='haskell'>mdm</code> 能在 $O(n)$ 時間之內完成計算。你可假設以下性質：<br>
<div><code class='haskell'><id='eq:max-minus'>
  & |maximum (map (x-) xs) = x - minimum xs| \mbox{~~.}
</code></div>
<p>並假設 <code class='haskell'>maximum</code> 與 <code class='haskell'>minimum</code> 在空串列上的值分別為 <code class='haskell'>-infty</code> 與 <code class='haskell'>infty</code>.</p>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>由  eqref eq:max-minus  我們推測：</p>
<div><pre class='spec'>
mdm :: List Int -> (Int :* Int)
mdm xs = (maxdiff xs, minimum xs) {-"~~."-}
</pre></div>
我們試圖找出 <code class='haskell'>mdm</code> 的歸納定義。顯然 <code class='haskell'>mdm [] = (-infty, infty)</code>.考慮歸納情況（令 <code class='haskell'>minus (x,y) = x-y</code>）：<br>

<div><pre style='display:none'>
minus (x,y) = x-y

mdmDer1 :: Int -> List Int -> (Int :* Int)
mdmDer1 x xs =
</pre></div>
 <div><pre style='display:none'>
      mdm (x:xs)
 ===    {- |mdm|, |maxdiff|, 與 |minimum| 之定義 -}
      (maximum (map minus (allpairs (x:xs))), x `min` minimum xs)
 ===  (  maximum (map minus (map (\y -> (x,y)) xs ++ allpairs xs)),
         x `min` minimum xs) {-"~~."-}
</pre></div>
集中焦點在序對的第一個元素：<br>

<div><pre style='display:none'>
mdmDer2 :: Int -> List Int -> Int
mdmDer2 x xs =
</pre></div>
 <div><pre style='display:none'>
      maximum (map minus (map (\y -> (x,y)) xs ++ allpairs xs))
 ===     {- 因 |map f (xs ++ ys) = map f xs ++ map f ys| (習題 \ref{ex:map-append}) -}
      maximum (  map minus (map (\y -> (x,y)) xs) ++
                 map minus (allpairs xs))
 ===     {- |map|-fusion -}
      maximum (map (x-) xs ++ map minus (allpairs xs))
 ===     {- 因 |maximum (xs ++ ys) = maximum xs `max` maximum ys| -}
      maximum (map (x-) xs) `max` maximum (map minus (allpairs xs))
 ===     {- 因 \eqref{eq:max-minus} -}
      (x - minimum xs) `max` maximum (map minus (allpairs xs))
 ===     {- |maxdiff| 之定義 -}
      (x - minimum xs) `max` maxdiff xs {-"~~."-}
</pre></div>
回到推導主體：<br>

<div><pre style='display:none'>
mdmDer3 :: Int -> List Int -> (Int :* Int)
mdmDer3 x xs =
</pre></div>
 <div><pre style='display:none'>
      mdm (x:xs)
 ===    {- 上述計算 -}
      ((x - minimum xs) `max` maxdiff xs , x `min` minimum xs)
 ===    {- 使用 |let| -}
      let (y, z) = (maxdiff xs, minimum xs)
      in ((x - z) `max` y, x `min` z)
 ===    {- |mdm| 之定義 -}
      let (y, z) = mdm xs
      in ((x - z) `max` y, x `min` z)  {-"~~."-}
</pre></div>
於是我們得知：<br>
<div><pre style='display:none'>
mdm []      =  (minBound, maxBound)
mdm (x:xs)  =  let (y, z) = mdm xs
               in ((x - z) `max` y, x `min` z)  {-"~~."-}
</pre></div>
</div>
</div>
<h2 class='section' >累積參數<id='sec:accumulating-param'></h2><p>在第  ref sec:efficiency-basics  節中，我們曾提及該處定義的 <code class='haskell'>reverse :: List a -> List a</code> 需要 $O(n^2)$ 的時間。是否有比較快的作法呢？</p>
<h3 class='subsection' >串列反轉與連接<id='sec:reversal-append'></h3><p>下列函數 <code class='haskell'>revcat</code> 似乎比 <code class='haskell'>reverse</code> 更通用一些：它拿兩個參數 <code class='haskell'>xs</code> 與 <code class='haskell'>ys</code>, 不僅將 <code class='haskell'>xs</code> 反轉，還把 <code class='haskell'>ys</code> 接到反轉後結果的右邊：%<p class='footer'><code class='haskell'>revcat</code> 為 <code>reverse'' 與<code>concat'' 的簡寫。</p></p>
<div><pre style='display:none'>
revcat :: List a -> List a -> List a
revcat xs ys = reverse xs ++ ys {-"~~."-}
</pre></div>
原有的 <code class='haskell'>reverse</code> 可以視為 <code class='haskell'>revcat</code> 的特例 --- <code class='haskell'>reverse xs = revcat xs []</code>.這裡是否也會出現<em>責任越大，能力越強</em>的現象：看似做了比較多事情的 <code class='haskell'>revcat</code> 其實反倒有比較有效率的實作呢？我們試著演算看看！當 <code class='haskell'>xs := []</code>, 顯然 <code class='haskell'>revcat [] ys = ys</code>.考慮 <code class='haskell'>xs := x:xs</code> 的情況：<br>

<div><pre style='display:none'>
revcatDer x xs ys =
</pre></div>
 <div><pre style='display:none'>
      revcat (x:xs) ys
 ===    {- |revcat| 之定義 -}
      reverse (x:xs) ++ ys
 ===    {- |reverse| 之定義 -}
      (reverse xs ++ [x]) ++ ys
 ===    {- |(++)| 之結合律 -}
      reverse xs ++ ([x] ++ ys)
 ===    {- |(++)| 與 |revcat| 之定義 -}
      revcat xs (x : ys) {-"~~."-}
</pre></div>
因此我們有了：<br>
<div><pre class='spec'>
revcat []      ys = ys
revcat (x:xs)  ys = revcat xs (x:ys) {-"~~."-}
</pre></div>
我們看看 <code class='haskell'>revcat [1,2,3,4] []</code> 如何歸約：<br>
<div><pre class='spec'>
   revcat (1:2:3:4:[]) []
=  revcat (2:3:4:[]) (1:[])
=  revcat (3:4:[]) (2:1:[])
=  revcat (4:[]) (3:2:1:[])
=  revcat [] (4:3:2:1:[])
=  [4,3,2,1] {-"~~."-}
</pre></div>
串列 <code class='haskell'>[1,2,3,4]</code> 中的元素一個個被搬到 <code class='haskell'>revcat</code> 的第二個參數中。這是一個常數時間內可完成的動作，而每個元素只會被搬動一次。因此當 <code class='haskell'>xs</code> 的長度是 <code class='haskell'>n</code>，<code class='haskell'>reverse xs ys</code> 可在 $O(n)$ 的時間內執行完畢！<br>
<p>我們剛看到的技巧和第  ref sec:tupling  節中的組對互為對偶。在第  ref sec:tupling  節中，我們為了導出一個函數的較快版本，讓它多傳回一些資訊。而在本節，我們則讓一個函數多吃些參數，多接受些資訊。通常這些新介紹的參數用於「累積」計算到目前為止的結果，例如在 <code class='haskell'>revcat</code> 中，參數 <code class='haskell'>ys</code> 存放被反轉到一半的串列。因此這個技巧被稱作<em>累積參數</em>(<em>accumulating parameters</em>) index accumulating parameters 累積參數 。</p>
<p>很多情況下，累積參數的運用仰賴某些運算元的結合律。觀察 <code class='haskell'>revcat</code> 的推導，關鍵的一步便是 <code class='haskell'>(++)</code> 的結合律。它使我們能夠把 <code class='haskell'>(reverse xs ++ [x]) ++ ys</code> 轉換為 <code class='haskell'>reverse xs ++ ([x] ++ ys)</code>，將<code class='haskell'>[x]</code> 往右搬，才能收回、累積到 <code class='haskell'>revcat</code> 的第二個參數 <code class='haskell'>ys</code> 中。</p>
<p>回顧起來，我們最初如何發明出 <code class='haskell'>revcat xs ys = reverse xs ++ ys</code> 這樣的定義呢？一個解釋便是：<code class='haskell'>reverse</code> 之所以慢，是因為 <code class='haskell'>(++)</code> 的括號都括錯了方向，往左邊括了。因此我們在右邊補一個 <code class='haskell'>(++ ys)</code>, 希望用 <code class='haskell'>(++)</code> 的結合律，將括號往右挪。</p>
<p>我們多看一個例子。以下函數 <code class='haskell'>tags</code> 傳回一棵 <code class='haskell'>ITree</code> 中所有的標籤：</p>
<div><pre style='display:none'>
tags :: ITree a -> List a
tags Null          = []
tags (Node x t u)  = tags t ++ [x] ++ tags u {-"~~."-}
</pre></div>
和習題  ref ex:ETree-tips  的情況類似，當 <code class='haskell'>t</code> 是一棵向左傾斜的樹，<code class='haskell'>tags</code> 會需要 $O(n^2)$ 的時間。例如，考慮這棵樹 <code class='haskell'>t</code> （以下將 <code class='haskell'>Node x Null Null</code> 簡寫為 <code class='haskell'>lv x</code>）：<br>
<div><pre class='spec'>
  t = Node 7  (Node 6  (Node 4  (Node 2 (lv 1) (lv 3))
                       (lv 5)))
              (lv 8) {-"~~."-}
</pre></div>
將 <code class='haskell'>tags t</code> 展開（並為說明方便，將一些 <code class='haskell'>[]++[x]++[]</code> 化簡為 <code class='haskell'>[x]</code>），我們會得到：<br>
<div><pre class='spec'>
 ((([1] ++ [2] ++ [3])  ++ [4]
                        ++ [5]) ++ [6]) ++ [7] ++ [8] {-"~~."-}
</pre></div>
這個式子的結構和 <code class='haskell'>t</code> 一樣，只是將 <code class='haskell'>Node x...</code> 都變為 <code class='haskell'>.. ++ [x] ++ ..</code>.我們可看到 <code class='haskell'>(++[6])</code> 需要走過一個長度為 <code class='haskell'>5</code> 的串列，<code class='haskell'>(++[7])</code> 需要走過一個長度為 <code class='haskell'>6</code> 的串列。<br>
<p>為了避免 <code class='haskell'>(++)</code> 的重複走訪，我們在 <code class='haskell'>tags t</code> 的左邊補一個 <code class='haskell'>(++ys)</code>, 希望透過結合律改變括號的順序。我們定義：</p>
<div><pre style='display:none'>
tagsAcc :: ITree a -> List a -> List a
tagsAcc t ys = tags t ++ ys {-"~~."-}
</pre></div>
利用 <code class='haskell'>(++)</code> 的結合律，讀者應不難導出如下的歸納定義：<br>
<div><pre class='spec'>
tagsAcc Null          ys = ys
tagsAcc (Node x t u)  ys = tagsAcc t (x : tagsAcc u ys) {-"~~."-}
</pre></div>
之後我們便可重新定義 <code class='haskell'>tags t = tagsAcc t []</code>.至於 <code class='haskell'>tagsAcc</code> 的效率如何呢？如果將 <code class='haskell'>tagsAcc t ys</code> 展開，我們順利地得到：<br>
<div><pre class='spec'>
 1 : (2 : (3 : (4 : (5 : (6 : (7 : (8 : ys))))))) {-"~~."-}
</pre></div>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>由 <code class='haskell'>tagsAcc t ys = tags t ++ ys</code> 推導出上述的歸納定義。</p>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>僅看 <code class='haskell'>t := Node x t u</code> 的狀況：</p>

<div><pre style='display:none'>
tagsDer1 :: a -> ITree a -> ITree a -> List a -> List a
tagsDer1 x t u ys =
</pre></div>
 <div><pre style='display:none'>
      tagsAcc (Node x t u) ys
 ===  tags (Node x t u) ++ ys
 ===  (tags t ++ [x] ++ tags u) ++ ys
 ===    {- |(++)| 的結合律 -}
      tags t ++ (x : tags u ++ ys)
 ===  tagsAcc t (x : tagsAcc u ys) {-"~~."-}
</pre></div>
我們可導出：<br>
<div><pre class='spec'>
tagsAcc Null          ys = ys
tagsAcc (Node x t u)  ys = tagsAcc t (x : tagsAcc u ys) {-"~~."-}
</pre></div>
</div>
<div class = 'Exercise'>
<b>練習:</b>
<p>確認 <code class='haskell'>tagsAcc t ys</code> 確實是 <code class='haskell'>1 : (2 : (3 : (4 : (5 : (6 : (7 : (8 : ys)))))))</code>.</p>
</div>
<div class = 'Exercise'>
<b>練習:</b><id='ex:ETree-tipsAcc'>
<p>接續習題  ref ex:ETree-tips ，利用累積參數，推導出一個只需線性時間的 <code class='haskell'>tips :: ETree a -> List a</code>.</p>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>定義 <code class='haskell'>tipsAcc t ys = tips t ++ ys</code>.如果 <code class='haskell'>tipsAcc</code> 有個有效率的定義，我們可改定義 <code class='haskell'>tips t = tipsAcc t []</code>.當 <code class='haskell'>t := Tip x</code>, <code class='haskell'>tipsAcc (Tip x) ys</code> 可直接展開為 <code class='haskell'>x:ys</code>.當 <code class='haskell'>t := Bin t u</code>,</p>

<div><pre style='display:none'>
tipsAcc :: ETree a -> List a -> List a
tipsAcc t ys = tips t ++ ys

tipsAccDer1 :: ETree a -> ETree a -> List a -> List a
tipsAccDer1 t u ys =
</pre></div>
 <div><pre style='display:none'>
      tipsAcc (Bin t u) ys
 ===  (tips t ++ tips u) ++ ys
 ===    {- |(++)| 之結合律 -}
      tips t ++ (tips u ++ ys)
 ===  tipsAcc t (tipsAcc u ys) {-"~~."-}
</pre></div>
因此，<br>
<div><pre class='spec'>
tipsAcc (Tip x)    ys = x : ys
tipsAcc (Bin t u)  ys = tipsAcc t (tipsAcc u ys) {-"~~."-}
</pre></div>
</div>
</div>
<h3 class='subsection' >尾遞迴<id='sec:tail-recursion'></h3><p>關於第  ref sec:reversal-append  節的 <code class='haskell'>revcat</code> 有許多面向可談。本節先用它帶出一個重要的觀念：尾遞迴。</p>
<p>從第  ref ch:induction  章起，我們常見的歸納定義形式如下：</p>
<table>
<tr>
0.5\textwidth<td>
<div><pre class='spec'>
f []      = ...
f (x:xs)  = ... f xs ... {-"~~."-}
</pre></div>
</td>
</tr>
<tr>
0.5\textwidth<td>
<div><pre class='spec'>
sum []      = 0
sum (x:xs)  = x + sum xs {-"~~."-}
</pre></div>
</td>
</tr>
</table>
<p>右側的 <code class='haskell'>sum</code> 函數便是一個典型的例子。我們通常必須對遞迴呼叫的結果做些加工。例如此處 <code class='haskell'>sum xs</code> 的結果需要經過 <code class='haskell'>(x+)</code>, 才成為 <code class='haskell'>sum (x:xs)</code> 的值。實作上，電腦在執行 <code class='haskell'>sum xs</code> 的程式碼前必須記下「<code class='haskell'>sum xs</code> 回傳後，必須回來執行 <code class='haskell'>(x+)</code>」這件事。這可能用堆疊或著其他方式達成。無論如何，當 <code class='haskell'>xs</code> 長度為 <code class='haskell'>n</code>, 便有大約 <code class='haskell'>n</code> 個這種「尚待完成的計算」被暫存著。當 <code class='haskell'>xs</code> 被走訪到了基底狀況，這些暫存的計算才一個個被收回。</p>
<p>但 <code class='haskell'>revcat</code> 的情況卻有點不同。觀察其程式碼，會發現遞迴呼叫 <code class='haskell'>revcat xs (x:ys)</code> 的結果本身就是其左手邊 <code class='haskell'>revcat (x:xs) ys</code> 的值，不需其他的加工：</p>
<div><pre class='spec'>
revcat []      ys = ys
revcat (x:xs)  ys = revcat xs (x:ys) {-"~~."-}
</pre></div>
因此，<code class='haskell'>revcat</code> 的實作中，遞迴呼叫完成後，電腦不需回到原呼叫之處再執行什麼東西：最後的結果 <code class='haskell'>ys</code> 可直接傳回到最上層、第一個呼叫 <code class='haskell'>revcat</code> 的地方！<p class='footer'>如果該語言的實作確實有做到這點，我們說它實作了<em>尾呼叫消除</em>(<em>tail call elimination</em>)或<em>尾呼叫最佳化</em>(<em>tail call optimisation</em>)。有些語言到了蠻晚的版本才支援這個最佳化。</p><br>
<p>當一個函數 <code class='haskell'>f</code> 呼叫函數 <code class='haskell'>g</code> 時，如果該呼叫本身就是函數 <code class='haskell'>f</code> 最後的結果，並沒有針對傳回值的額外計算，我們將它稱之為一個<em>尾呼叫</em>(<em>tail call</em>)。 index tail call 尾呼叫 此名稱的由來可能是因為該呼叫是一連串計算後「最尾端」的動作。如果這是一個遞迴呼叫，則稱之為<em>尾遞迴</em>(<em>tail recursion</em>)。 index tail recursion 尾遞迴 </p>
%{
%format e1
%format e2
%format do = "\mathbf{do}"
%format od = "\mathbf{od}"<br>22
尾遞迴與迴圈 函數語言中的尾遞迴程式和指令式語言中的迴圈有相當密切的關係。回顧 <code class='haskell'>revcat [1,2,3,4] []</code> 的歸約過程：<br>
<div><pre class='spec'>
   revcat (1:2:3:4:[]) []
=  revcat (2:3:4:[]) (1:[])
=  revcat (3:4:[]) (2:1:[])
=  revcat (4:[]) (3:2:1:[])
=  revcat [] (4:3:2:1:[])
=  [4,3,2,1] {-"~~,"-}
</pre></div>
其實看來就像是一個有兩個變數的迴圈，其中一個由 <code class='haskell'>1:2:3:4:[]</code> 逐漸縮短為 <code class='haskell'>[]</code>，另一個由 <code class='haskell'>[]</code> 逐步增長為 <code class='haskell'>4:3:2:1:[]</code>.函數 <code class='haskell'>reverse</code> 的定義 <code class='haskell'>reverse xs = revcat xs []</code> 就是為這兩個變數設定初始值：如果要計算 <code class='haskell'>xs</code> 的反轉，兩變數應該分別初始化為 <code class='haskell'>xs</code> 與 <code class='haskell'>[]</code>.在 <code class='haskell'>revcat</code> 的定義中，<code class='haskell'>revcat [] ys</code> 表示該迴圈在第一個變數為 <code class='haskell'>[]</code> 時終止，此時程式傳回 <code class='haskell'>ys</code>；而<code class='haskell'>revcat (x:xs) ys = revcat xs (x:ys)</code> 則指定了在迴圈的每一步中兩個變數的值如何改變。函數 <code class='haskell'>reverse</code> 與 <code class='haskell'>revcat</code> 的組合相當於是這樣的一個指令式語言迴圈（假設 <code class='haskell'>xs</code> 與 <code class='haskell'>ys</code> 為變數，<code class='haskell'>XS</code> 為欲反轉的串列）：<p class='footer'><code class='haskell'>xs, ys := e1, e2</code> 將 <code class='haskell'>e1</code> 與 <code class='haskell'>e2</code> 兩個值同時給予 <code class='haskell'>xs</code> 與 <code class='haskell'>ys</code>; <code class='haskell'>do B -> S od</code> 表示一個迴圈，當 <code class='haskell'>B</code> 還成立時便反覆執行 <code class='haskell'>S</code>.</p><br>
<div><pre class='spec'>
xs, ys := XS, [];
do xs /= [] ->
   xs, ys := tail xs, head xs : ys
od ;
return ys
</pre></div>
%} %GCL<br>22
<p>而該迴圈的恆式(loop invariant)是什麼呢？正是 <code class='haskell'>reverse XS = reverse xs ++ ys</code> --- 右手邊就是 <code class='haskell'>revcat</code> 的定義。</p>
<p>一般說來，一個尾遞迴函數可視為一個迴圈，其參數就是迴圈中的變數。遞迴呼叫時參數改變，相當於更新這些變數的值，其基底狀況則相當於迴圈的終止條件。當我們為了計算某個函數 <code class='haskell'>f</code> 而設計了另一個較通用、可寫成尾遞迴的函數 <code class='haskell'>fAcc</code>,<code class='haskell'>fAcc</code> 的定義(例如 <code class='haskell'>reverse xs ++ ys</code>)往往就是這個迴圈的<em>恆式</em>(<em>loop invariant</em>)。 index loop invariant 迴圈恆式 在指令式程式推導的方法學中，設計一個迴圈最難之處便是決定其恆式。如第  ref sec:tupling-conclude  節所言，一般來說，並沒有一個固定的方法讓我們由 <code class='haskell'>f</code> 找出 <code class='haskell'>fAcc</code>。但我們仍可讓符號推演幫我們一些忙，並歸納出一些常見的模式。</p>
串列總和 累積參數的技巧常被用來推導尾遞迴程式（雖然累積參數的應用並不僅止於此）。我們多看一個例子。如前所述，<code class='haskell'>sum</code> 函數每次被遞迴呼叫時會需要用堆疊或其他等價的方式記住每個 <code class='haskell'>(x+)</code>。是否能避免這麼做呢？我們定義：<br>
<div><pre style='display:none'>
sumAcc :: List Int -> Int -> Int
sumAcc xs y = y + sum xs {-"~~."-}
</pre></div>
如此定義 <code class='haskell'>sumAcc</code> 的直覺理由是：我們想用參數 <code class='haskell'>y</code> 存放累積的結果，希望利用 <code class='haskell'>(+)</code> 的結合律逐步把 <code class='haskell'>sum xs</code> 的結果搬入 <code class='haskell'>y</code> 中。同樣地，一但找到了這個定義，之後的演算便相當日常、例行了。我們先記下：<code class='haskell'>sum xs = sumAcc xs 0</code>.接下來試圖導出 <code class='haskell'>sumAcc</code> 的歸納定義。在基底情況中，我們會需要 <code class='haskell'>y + 0 = y</code>。為了目睹結合律如何運作，我們看看 <code class='haskell'>xs := x:xs</code> 的狀況：<br>
<div><pre class='spec'>
     sumAcc (x:xs) y
===  y + sum (x:xs)
===  y + (x + sum xs)
===    {- |(+)| 之結合律 -}
     (y+x) + sum xs
===  sumAcc xs (y+x) {-"~~."-}
</pre></div>
讀者可能發現我們之所以定義 <code class='haskell'>sumAcc xs y</code> 為 <code class='haskell'>y + sum xs</code>, 而不是 <code class='haskell'>sum xs + y</code>, 是為了在使用結合律的那一步之中讓 <code class='haskell'>x</code> 可以就近與 <code class='haskell'>y</code> 結合。當然，<code class='haskell'>(+)</code> 也滿足交換律，因此兩個定義其實是一樣的。當我們處理沒有交換律的運算元時，就得對這類細節更小心了。總之，我們可導出以下的程式：<br>
<div><pre class='spec'>
sumAcc []      y = y
sumAcc (x:xs)  y = sumAcc xs (y + x) {-"~~."-}
</pre></div>
%{
%format x0
%format x1
%format xN1 = "\Varid{x}_{N-1}"
%format xi = "\Varid{x}_{i}"<br>22
<p>這可翻譯成下述的兩種迴圈之一。左手邊的程式將串列 <code class='haskell'>XS</code> 加總，使用的兩個變數 <code class='haskell'>xs</code> 與 <code class='haskell'>y</code> 對應到 <code class='haskell'>sumAcc</code> 的兩個參數。在右邊的程式中，我們假設輸入資料 <code class='haskell'>[x0, x1.. xN1]</code> 依序被存放在一個陣列 <code class='haskell'>X</code> 中。陣列有 <code class='haskell'>N</code> 個元素，其索引範圍為 <code class='haskell'>[0.. N-1]</code>.我們把陣列視為索引到內容的函數，因此 <code class='haskell'>X i</code> 存放著 <code class='haskell'>xi</code>.</p>
%format do = "\mathbf{do}"
%format od = "\mathbf{od}"<br>22
<table>
<tr>
0.5\textwidth<td>
<div><pre class='spec'>
xs, y := XS, 0;
do xs /= [] ->  y   := y + head xs ;
                xs  := tail xs
od ;
return y
</pre></div>
</td>
</tr>
<tr>
0.45\textwidth<td>
<div><pre class='spec'>
i, y := 0, 0;
do i /= N ->  y  := y + X i ;
              i  := i + 1
od ;
return y
</pre></div>
</td>
</tr>
</table>
%} %GCL<br>22
<p>確實，這就是我們一般用指令式語言加總一個串列/陣列時的常見迴圈寫法：由左到右走訪，用一個變數存放目前為止的和。以往許多人可能都沒注意到：同樣是「將 <code class='haskell'>xs</code> 由左到右走一遍」，這個程式和 <code class='haskell'>sum xs</code> 是不同的演算法！<code class='haskell'>sum [1,2,3,4]</code> 算出的是 <code class='haskell'>1 + (2 + (3 + (4 + 0)))</code>,而上述的、我們常用的那個迴圈算出的是 <code class='haskell'>(((0 + 1) + 2) + 3) + 4</code>.多虧 <code class='haskell'>(+)</code> 的結合律，它們剛好是一樣的。</p>
在迴圈中處理串列 在本節的結尾，我們更完整地討論一下歸納式的串列處理與迴圈的關係。初次閱讀的讀者可跳過本段。假設某函數 <code class='haskell'>f :: List A -> B</code> 能寫成如下的形式：<br>

<div><pre style='display:none'>
tmp1 = undefined
 where
 e :: Int
 e = undefined
 oplus :: Bool -> Int -> Int
 oplus = undefined
</pre></div>
 <div><pre style='display:none'>
 f []      = e
 f (x:xs)  = x `oplus` f xs {-"~~,"-}
</pre></div>
其中 <code class='haskell'>e :: B</code>, <code class='haskell'>oplus :: A -> B -> B</code>, 此處不假設 <code class='haskell'>oplus</code> 滿足結合律。我們能用一個尾遞迴函數（或著說用一個迴圈）計算 <code class='haskell'>f</code> 嗎？直覺上，我們可用一個迴圈將串列從右往左走一遍，並用變數紀錄目前為止算出的值。確實，如果我們要求如下的規格：<br>
<div><code class='haskell'><id='eq:fold-loop'>
|loop xs (f ys)| &|= f (xs ++ ys) {-"~~,"-}|
</code></div>
（所以 <code class='haskell'>f xs = loop xs (f []) = loop xs e</code>）並分析 <code class='haskell'>xs := []</code> 和 <code class='haskell'>xs := xs++[x]</code> 的情況如下：<br>
<table>
<tr>
0.4\textwidth<td>
<div><pre class='spec'>
    loop [] (f ys)
===   {- |loop| 之規格 -}
    f ([] ++ ys)
===   {- |(++)| 之定義 -}
    f ys {-"~~,"-}
</pre></div>
</td>
</tr>
<tr>
0.5\textwidth<td>
<div><pre class='spec'>
    loop (xs++[x]) (f ys)
===   {- |loop| 之規格 -}
    f (xs ++ [x] ++ ys)
===   {- |(++)| 之結合律，|loop| 之規格 -}
    loop xs (f (x:ys))
=== loop xs (x `oplus` f ys) {-"~~."-}
</pre></div>
</td>
</tr>
</table>
<p>可知如下定義的 <code class='haskell'>loop</code> 能滿足  eqref eq:fold-loop ：</p>
<div><pre class='spec'>
loop []           z = z
loop (xs ++ [x])  z = loop xs (x `oplus` z) {-"~~."-}
</pre></div>
<p>但從串列尾端取出元素較不方便。如果我們改用下式作為規格：</p>
<div><code class='haskell'><id='eq:fold-loop-rev'>
|loop xs (f ys)| &|= f (reverse xs ++ ys) {-"~~,"-}|
</code></div>
可推導出<br>
<div><pre style='display:none'>
 loop []      z = z
 loop (x:xs)  z = loop xs (x `oplus` z) {-"~~."-}
</pre></div>
但此時要用 <code class='haskell'>loop</code> 計算出 <code class='haskell'>f xs</code>，得先將 <code class='haskell'>xs</code> 反轉：<code class='haskell'>f xs = loop (reverse xs) e</code>.這具體印證了我們的觀察：在串列上歸納定義出的函數，處理元素的順序和通常寫法的迴圈是相反的。<br>
%{
%format x0
%format x1
%format xN1 = "\Varid{x}_{N-1}"
%format xN2 = "\Varid{x}_{N-2}"
%format xi = "\Varid{x}_{i}"
%format do = "\mathbf{do}"
%format od = "\mathbf{od}"<br>22
<p>假設有 <code class='haskell'>N</code> 個元素的串列 <code class='haskell'>xs = [x0, x1 ... xN1]</code> 被<em>反過來</em>存放在陣列 <code class='haskell'>X</code> 之中，意即 <code class='haskell'>X 0 = xN1</code>, <code class='haskell'>X 1 = xN2</code>, ... <code class='haskell'>X (n-1) = x0</code>.前述的兩種 <code class='haskell'>loop</code> 函數都可在不同的詮釋下理解為如下的指令式程式。</p>
<div><pre class='spec'>
i, z := 0, e;
do i /= N ->  z  := X i `oplus` z ;
              i  := i + 1
od ;
return z {-"~~."-}
</pre></div>
%} %GCL<br>22
<h3 class='subsection' >更多尾遞迴範例<id='sec:tail-recursion-more'></h3><p>我們多看些使用結合律推導出尾遞迴程式，並增進效率的例子。</p>
快速乘冪  說到結合律的應用，似乎不得不提作為經典例子的乘冪。我們在第  ref sec:exp-binary-roll  節中曾用二進位表示法導出一個用 $O(\log n)$ 個乘法計算 $b^n$ 的程式。此處我們使用結合律推導出尾遞迴的版本。回顧函數 <code class='haskell'>exp</code> 在第  ref sec:induction-on-Nat  節中的定義，乘冪便是連續的乘法。我們定義以下的函數 <code class='haskell'>expAcc</code>，把 <code class='haskell'>exp b n</code> 乘上一個累積參數 <code class='haskell'>x</code>，希望將一些中間結果搬移到 <code class='haskell'>x</code> 中：<br>
<div><pre class='spec'>
expAcc :: Nat -> Nat -> Nat -> Nat
expAcc b n x = x * exp b n {-"~~."-}
</pre></div>
如果 <code class='haskell'>expAcc</code> 有快速的定義，我們可以令 <code class='haskell'>exp b n = expAcc b n 1</code>.然後我們針對 <code class='haskell'>n</code> 為零、<code class='haskell'>n</code> 為非零的偶數，以及 <code class='haskell'>n</code> 為奇數三種情況作分析。當 <code class='haskell'>n := 0</code>, <code class='haskell'>expAcc b 0 x = x</code>. 當 <code class='haskell'>n</code> 為偶數時，可以被改寫成 <code class='haskell'>2*n</code>.以下的推導中我們將 <code class='haskell'>exp b n</code> 寫成 $b^n$, 並假設它已有乘冪該有的各種性質：<br>
%{
%format exp b (n) = b "^{" n "}"<br>22

<div><pre style='display:none'>
expAccDer1 :: Int -> Int -> Int -> Int
expAccDer1 b n x =
</pre></div>
 <div><pre style='display:none'>
      expAcc b (2 * n) x
 ===  x * exp b (2 * n)
 ===   {- 因 |exp b (m * n) = exp (exp b m) n| -}
      x * exp (exp b 2) n
 ===   {- |expAcc| 之定義，|exp b 2 = b * b| -}
      expAcc (b * b) n x {-"~~."-}
</pre></div>
當 <code class='haskell'>n</code> 是奇數，我們將它改寫成 <code class='haskell'>1+n</code>:<br>

<div><pre style='display:none'>
expAccDer2 :: Int -> Int -> Int -> Int
expAccDer2 b n x =
</pre></div>
 <div><pre style='display:none'>
      expAcc b (1 + n) x
 ===  x * exp b (1+n)
 ===    {- $\Varid{exp}$ 之定義 -}
      x * (b * exp b n)
 ===    {- |(*)| 之結合律 -}
      (x * b) * exp b n
 ===    {- |expAcc| 之定義 -}
      expAcc b n (x * b) {-"~~."-}
</pre></div>
%} %exp<br>22
<p>將語法改寫成 Haskell 能接受的形式（例如將 <code class='haskell'>2 * n</code> 與 <code class='haskell'>n</code> 改寫成 <code class='haskell'>n</code> 與 <code class='haskell'>n `div` 2</code>）之後，我們得到這樣的程式：</p>
<div><pre style='display:none'>
expAcc b 0 x  = x
expAcc b n x  | even  n = expAcc (b * b) (n `div` 2) x
              | odd   n = expAcc b (n-1) (x*b) {-"~~."-}
</pre></div>
確實，這是一般在指令式語言中快速計算乘冪的方式。一個操作性的理解法是：<code class='haskell'>expAcc b n x</code> 開始執行後，第一個參數中總是存放著 <code class='haskell'>b</code> 的「<code class='haskell'>2</code> 的某個次方」的乘冪（$b$, $b^2$, $b^4$...）。只在 <code class='haskell'>n</code> 是奇數時，當時的 <code class='haskell'>b</code> 才會被乘入累積參數 <code class='haskell'>x</code> 之中。<br>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>本節的 <code class='haskell'>expAcc</code> 函數相當於怎樣的指令式語言迴圈？其迴圈恆式為何？</p>
</div>
%{
%format do = "\mathbf{do}"
%format od = "\mathbf{od}"
%format fi = "\mathbf{fi}"
%format exp b (n) = b "^{" n "}"<br>22
<div class = 'Answer'>
<b>答:</b>
<p>假設我們要計算 <code class='haskell'>exp B N</code>:</p>
<div><pre class='spec'>
b, n, x := B, N, 1;
do n /= 0 ->  if  even  n -> b, n := b * b, n `div` 2
              |   odd   n -> n, x := n - 1, x * b
              fi
od;
return x
</pre></div>
其迴圈恆式為 <code class='haskell'>exp B N = x * exp b n</code>.<br>
%} % GCL<br>22
</div>
</div>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>請推導出一個尾遞迴版本的 <code class='haskell'>length</code> 函數。</p>
</div>
</div>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>第  ref sec:inductive-proof-on-Nat  節中介紹了經典的階層函數：</p>
<div><pre class='spec'>
fact :: Nat -> Nat
fact Zero     = 1
fact (Suc n)  = (Suc n) *: fact n {-"~~."-}
</pre></div>
請推導出一個尾遞迴版本。您利用了關於 <code class='haskell'>(*:)</code> 的什麼性質？最後的程式是否像是一個計算 <code class='haskell'>n</code> 階層的指令式語言迴圈呢？<br>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>我們預期將利用 <code class='haskell'>(*:)</code> 的結合律。定義<code class='haskell'>factAcc n y = y *: fact n</code>。顯然 <code class='haskell'>factAcc Zero y = y</code>.至於 <code class='haskell'>n := Suc n</code> 的狀況：</p>
<div><pre class='spec'>
     factAcc (Suc n) y
===  y *: fact (Suc n)
===  y *: ((Suc n) *: fact n)
===    {- |(*:)| 之結合律 -}
     (y *: (Suc n)) *: fact n
===  factAcc n (y *: (Suc n)) {-"~~."-}
</pre></div>
因此我們有了下述定義。由於 <code class='haskell'>fact n = factAcc n 1</code>.這相當於右邊的迴圈：<br>
%{
%format do = "\mathbf{do}"
%format od = "\mathbf{od}"<br>22
<table>
<tr>
0.5\textwidth<td>
<div><pre class='spec'>
factAcc Zero     y = y
factAcc (Suc n)  y =
   factAcc n (y *: (Suc n)) {-"~~."-}
</pre></div>
</td>
</tr>
<tr>
0.5\textwidth<td>
<div><pre class='spec'>
n, y := N, 0;
do n /= 0 -> n, y := n-1, y * n od;
return y {-"~~."-}
</pre></div>
</td>
</tr>
</table>
%} %GCL<br>22
<p>在推導 <code class='haskell'>factAcc</code> 的歸納定義時，我們不僅用到 <code class='haskell'>(*:)</code> 的結合律，也用到了 <code class='haskell'>y *: 1 = y</code>.</p>
</div>
</div>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>第  ref sec:induction-on-Nat  節中把乘法定義為連續的加法。確實，一些早期、簡單的微電腦中沒有專做乘法的電路，只能以加法實作乘法。但如果有乘以二、除以二、以及判斷一個數字是奇數或偶數的指令（都是簡單的位元運算），我們只需 $O(\log m)$ 個加法即可計算 <code class='haskell'>m * n</code>. 定義：</p>
<div><pre class='spec'>
mulAcc m n k = k + m * n {-"~~."-}
</pre></div>
請推導出一個只使用加減法、乘以二、除以二、奇偶判斷，並在 $O(\log m)$ 的時間內算出 <code class='haskell'>mulAcc m n k</code> 的歸納定義。這個定義能被改寫成一個迴圈嗎？其恆式為何？<br>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>針對 <code class='haskell'>m</code> 做分析。基底情況中，<code class='haskell'>mulAcc 0 n k = k + 0 * n = k</code>.當 <code class='haskell'>m</code> 為非零的偶數，可被改寫為 <code class='haskell'>2 * m</code> 並演算如下：</p>

<div><pre style='display:none'>
mulAccDer1 :: Int -> Int -> Int -> Int
mulAccDer1 m n k =
</pre></div>
 <div><pre style='display:none'>
      mulAcc (2*m) n k
 ===  k + (2*m) * n
 ===   {- |(*)| 之交換律與結合律 -}
      k + m * (2 * n)
 ===  mulAcc m (2*n) k {-"~~."-}
</pre></div>
當 <code class='haskell'>m</code> 為奇數，可被改寫為 <code class='haskell'>1+m</code>, 並演算如下：<br>
<div><pre class='spec'>
      mulAcc (1+m) n k
 ===  k + (1+m) * n
 ===    {- |(*)| 分配進入 |(+)| -}
      k + n + m * n
 ===    {- |(+)| 之結合律，|mulAcc| 之定義 -}
      mulAcc m n (k + n) {-"~~."-}
</pre></div>
因此我們得到：<br>
<div><pre style='display:none'>
mulAcc 0 n k  = k
mulAcc m n k  | even n  = mulAcc (m `div` 2) (2*n) k
              | odd n   = mulAcc (m - 1) n (k + n) {-"~~."-}
</pre></div>
如果改寫成計算 <code class='haskell'>M * N</code> 的迴圈，其恆式為 <code class='haskell'>M * N = k + m * n</code>.<br>
</div>
</div>
<div class = 'exlist'>

%{
%format exp b (n) = b "^{" n "}"<br>22
<div class = 'Exercise'>
<b>練習:</b>
<p>下述函數 <code class='haskell'>dtoN</code> 將一個以串列表達的十進位數字轉成自然數。例如 <code class='haskell'>dtoN [4,1,6,0] = 4160</code>:</p>
<div><pre class='spec'>
dtoN :: List Nat -> Nat
dtoN []      = 0
dtoN (d:ds)  = d * exp 10 (length ds) + dtoN ds {-"~~."-}
</pre></div>
其中 <code class='haskell'>length ds</code> 的反覆計算使得 <code class='haskell'>dtoN</code> 成為一個需時 $O(n^2)$ 的演算法（<code class='haskell'>n</code> 為輸入串列的長度）。<br>
<ol>
<li>
<p>使用組對的技巧，導出一個能在 $O(n)$ 時間內計算 <code class='haskell'>dtoN</code> 以及一些其他輔助結果的函數。</p>
</li>
<li>
<p>使用累積參數，導出一個能在 $O(n)$ 時間內計算 <code class='haskell'>dtoN</code> 的尾遞迴函數。<b>提示</b>：可試試看用這樣的定義 <code class='haskell'>dtoNAcc ds n = ..n.. + dtoN ds</code>.</p>
</li>
</ol>

<div><pre style='display:none'>
dtoN [] = 0
dtoN (d:ds) = d * exp 10 (length ds) + dtoN ds
</pre></div>
 </div>
<div class = 'Answer'>
<b>答:</b>
<p>要使用組對避免重複計算，我們可以定義一個函數同時傳回 <code class='haskell'>dtoN ds</code> 以及 <code class='haskell'>10</code> 的 <code class='haskell'>length ds</code> 次方。</p>
<div><pre class='spec'>
dtoNT :: List Nat -> (Nat :* Nat)
dtoNT ds = (dtoN ds, exp 10 (length ds)) {-"~~."-}
</pre></div>
我們可輕易導出：<br>
<div><pre style='display:none'>
dtoNT []      = (0,1)
dtoNT (d:ds)  = (d * t + n, 10 * t) {-"~~,"-}
  where (n,t) = dtoNT ds {-"~~."-}
</pre></div>
若使用累積參數，可定義<br>
<div><pre class='spec'>
dtoNAcc ds n = n * exp 10 (length ds) + dtoN ds {-"~~."-}
</pre></div>
若有歸納定義，我們可令 <code class='haskell'>dtoN ds = dtoNAcc ds 0</code>.基底狀況為 <code class='haskell'>dtoNAcc [] n = n</code>.至於 <code class='haskell'>ds := d : ds</code> 的情況可演算如下：<br>

<div><pre style='display:none'>
dtoN'der1 d ds n =
</pre></div>
 <div><pre style='display:none'>
      dtoNAcc (d : ds) n
 ===  n * exp 10 (length (d:ds)) + dtoN (d:ds)
 ===  n * exp 10 (length (d:ds)) + d * exp 10 (length ds) + dtoN ds
 ===    {- |length| 與乘冪之定義 -}
      n * 10 * exp 10 (length ds) + d * exp 10 (length ds) + dtoN ds
 ===    {- 算數運算 -}
      (n * 10 + d) * exp 10 (length ds) + dtoN ds
 ===    {- |dtoNAcc| 之定義 -}
      dtoNAcc ds (n * 10 + d) {-"~~."-}
</pre></div>
可推導出：<br>
<div><pre style='display:none'>
dtoNAcc []      n = n
dtoNAcc (d:ds)  n = dtoNAcc ds (n * 10 + d) {-"~~."-}
</pre></div>
%} %exp<br>22
</div>
</div>
多個累積參數 我們以一個稍微複雜的例子結束本節。給定以下函數：<p class='footer'><code class='haskell'>masc</code> 為 ``mostly ascending'' 的縮寫。這個函數大致上遞增，但偶爾會掉下來一點點。</p><br>
<div><pre class='spec'>
masc :: Nat -> Nat
masc 0            = 1
masc (2 * n)      = 2 * masc n
masc (1 + 2 * n)  = n + masc n {-"~~."-}
</pre></div>

<div><pre style='display:none'>
masc :: Int -> Int
masc 0  = 1
masc n  | even  n = 2 * masc (n `div` 2)
        | odd   n =  (n `div` 2) + masc (n `div` 2) {-"~~."-}
</pre></div>
 <p>我們想用累積參數的技巧，推導出一個以尾遞迴計算 <code class='haskell'>masc n</code> 的演算法。最難的一步總是尋找一個合適的通用化。我們試著展開 <code class='haskell'>masc</code>, 看看是否能找到什麼規律。以 <code class='haskell'>masc 43</code> 為例：</p>
<div><pre class='spec'>
   masc 43
=  21 + masc 21
=  21 + 10 + masc 10
=  31 + masc 10
=  31 + 2 * masc 5
=  31 + 2 * (2 + masc 2)
=  35 + 2 * masc 2
=  35 + 4 * masc 1
=  35 + 4 * 1
=  39 {-"~~."-}
</pre></div>
我們發現式子總能展開成為 <code class='haskell'>a + b * masc n</code> 的形式。因此我們定義<br>
<div><pre class='spec'>
mascAcc :: Nat -> Nat -> Nat -> Nat
mascAcc n a b = a + b * masc n {-"~~."-}
</pre></div>
但在開始推導 <code class='haskell'>mascAcc</code> 前，我們得先確定 <code class='haskell'>masc</code> 能由 <code class='haskell'>mascAcc</code> 算得出來。幸好，我們可以讓 <code class='haskell'>masc n = mascAcc n 0 1</code>.<br>
<p>現在我們試著尋找 <code class='haskell'>mascAcc</code> 的尾遞迴定義。當 <code class='haskell'>n := 0</code>, <code class='haskell'>mascAcc 0 a b = a + b</code>.當 <code class='haskell'>n</code> 為非零的偶數，可以將它代換為 <code class='haskell'>2 * n</code>。我們推導：</p>

<div><pre style='display:none'>
mascAccDer1 :: Int -> Int -> Int -> Int
mascAccDer1 n a b =
</pre></div>
 <div><pre style='display:none'>
      mascAcc (2*n) a b
 ===  a + b * masc (2 * n)
 ===   {- |masc| 之定義 -}
      a + b * 2 * masc n
 ===  mascAcc n a (2 * b) {-"~~."-}
</pre></div>
而當 <code class='haskell'>n</code> 為奇數，可以寫成 <code class='haskell'>1 + 2 * n</code> 的形式：<br>

<div><pre style='display:none'>
mascAccDer2 :: Int -> Int -> Int -> Int
mascAccDer2 n a b =
</pre></div>
 <div><pre style='display:none'>
      mascAcc (1+2*n) a b
 ===  a + b * masc (1 + 2 * n)
 ===    {- |masc| 之定義 -}
      a + b * (n + masc n)
 ===    {- |(*)| 分配入 |(+)|, |(+)| 之結合律 -}
      (a + b * n) + b * masc n
 ===  mascAcc n (a + b * n) b {-"~~."-}
</pre></div>
因此我們有了如下的尾遞迴定義：<br>
<div><pre style='display:none'>
mascAcc 0 a b  = a + b
mascAcc n a b  | even  n = mascAcc (n `div` 2) a (2 * b)
               | odd   n = mascAcc (n `div` 2) (a + b * (n `div` 2)) b {-"~~."-}
</pre></div>
在推導 <code class='haskell'>mascAcc</code> 的過程中使用了各種四則運算的性質，但總之目標是將式子整理回 <code class='haskell'>a + b * masc n</code> 的形式，以便收回成為 <code class='haskell'>mascAcc</code>。<br>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>本題來自 citet Kaldewaij:90:Programming . 給定以下函數：</p>
<div><pre class='spec'>
fusc :: Nat -> Nat
fusc 0            = 0
fusc 1            = 1
fusc (2 * n)      = fusc n
fusc (1 + 2 * n)  = fusc n + fusc (1 + n)
</pre></div>

<div><pre style='display:none'>
fusc :: Int -> Int
fusc 0  = 0
fusc 1  = 1
fusc n  | even  n = fusc (n `div` 2)
        | odd   n = fusc (n `div` 2) + fusc (1 + (n `div` 2))
</pre></div>
 <p>請推導出一個計算 <code class='haskell'>fusc</code> 的尾遞迴程式。<b>提示</b>: 以 <code class='haskell'>fusc 78</code> 為例展開，看是否能找到什麼規律。</p>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>由於我們展開的式子都有 <code class='haskell'>a * fusc n + b * fusc (1 + n)</code> 的形式，定義</p>
<div><pre class='spec'>
 fuscAcc n a b = a * fusc n + b * fusc (1 + n) {-"~~."-}
</pre></div>
如果 <code class='haskell'>fuscAcc</code> 有歸納定義，我們可令 <code class='haskell'>fusc n = fuscAcc n 1 0</code>.<br>
<p>為推導 <code class='haskell'>fuscAcc</code>, 針對 <code class='haskell'>n</code> 做分析。當 <code class='haskell'>n := 0</code>, <code class='haskell'>fuscAcc 0 a b = b</code>.當 <code class='haskell'>n</code> 為非零偶數，可被改寫為 <code class='haskell'>2 * n</code>:</p>

<div><pre style='display:none'>
fuscAccDer1 :: Int -> Int -> Int -> Int
fuscAccDer1 n a b =
</pre></div>
 <div><pre style='display:none'>
      fuscAcc (2 * n) a b
 ===  a * fusc (2 * n) + b * fusc (1 + 2 * n)
 ===    {- |fusc| 之定義 -}
      a * fusc n + b * (fusc n + fusc (1 + n))
 ===    {- 四則運算 -}
      (a + b) * fusc n + b * fusc (1 + n)
 ===  fuscAcc n (a + b) b {-"~~."-}
</pre></div>
當 <code class='haskell'>n</code> 為奇數，也就是可改寫為 <code class='haskell'>1 + 2 * n</code> 的形式時：<br>

<div><pre style='display:none'>
fuscAccDer2 :: Int -> Int -> Int -> Int
fuscAccDer2 n a b =
</pre></div>
 <div><pre style='display:none'>
      fuscAcc (1 + 2 * n) a b
 ===  a * fusc (1 + 2 * n) + b * fusc (2 + 2 * n)
 ===  a * fusc (1 + 2 * n) + b * fusc (2 * (1 + n))
 ===    {- |fusc| 之定義 -}
      a * (fusc n + fusc (1 + n)) + b * fusc (1 + n)
 ===    {- 四則運算 -}
      a * fusc n + (a + b) * fusc (1 + n)
 ===  fuscAcc n a (a + b) {-"~~."-}
</pre></div>
因此我們有了如下的程式：<br>
<div><pre style='display:none'>
fuscAcc 0 a b  = b
fuscAcc n a b  | even  n = fuscAcc (n `div` 2) (a + b) b
               | odd   n = fuscAcc (n `div` 2) a (a + b) {-"~~."-}
</pre></div>
</div>
</div>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b><id='ex:mapAcc'>
<p>我們能以尾遞迴的方式做 <code class='haskell'>map f</code> 嗎？如果以 <code class='haskell'>mapAcc f xs ys</code> <code class='haskell'>= ys ++ map f xs</code> 為規格, 我們會導出如下的歸納定義：</p>
<div><pre class='spec'>
mapAcc f []      ys = ys
mapAcc f (x:xs)  ys = mapAcc f xs (ys++[f x]) {-"~~."-}
</pre></div>
<p>但重複的 <code class='haskell'>(++ [f x])</code> 需要 $O(n^2)$ 的時間。請問用什麼樣的規格才能導出下面的歸納定義呢？</p>
<div><pre class='spec'>
mapAcc f []      ys = reverse ys
mapAcc f (x:xs)  ys = mapAcc f xs (f x : ys) {-"~~."-}
</pre></div>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>使用如下的規格：</p>
<div><pre style='display:none'>
mapAcc :: (a -> b) -> List a -> List b -> List b
mapAcc f xs ys = reverse ys ++ map f xs {-"~~."-}
</pre></div>
因此 <code class='haskell'>mapAcc f [] ys = reverse ys</code>. 而 <code class='haskell'>xs := x : xs</code> 的情況推導如下：<br>

<div><pre style='display:none'>
mapAccDer1 f x xs ys =
</pre></div>
 <div><pre style='display:none'>
      mapAcc f xs ys
 ===  reverse ys ++ map f (x:xs)
 ===  reverse ys ++ (f x : map f xs)
 ===  (reverse ys ++ [f x]) ++ map f xs
 ===  reverse (f x : ys) ++ map f xs
 ===  mapAcc f xs (f x : ys) {-"~~."-}
</pre></div>
</div>
</div>
<h3 class='subsection' >尾遞迴的效率考量</h3><p>如前一節所述，歸納定義的 <code class='haskell'>sum</code> 需用堆疊（或其他功能相當的機制）記下每個遞迴呼叫的結果該怎麼加工。這會佔用與輸入串列長度成正比的額外空間，相當不理想 --- 直覺上，「將一個串列加總」應該是只需定量的額外空間即可完成的計算。尾遞迴的 <code class='haskell'>sumAcc</code> 則只需用一個變數存放目前為止的總和，當串列走訪到底，可直接將這個總和傳到最上層，似乎合理多了。因此，在以效率為考量的函數語言程式庫中，諸如加總、算最小值等等的函數幾乎都是以尾遞迴方式寫成的。大部分函數語言使用<em>及早求值</em> --- 在呼叫一個函數之前，總是把其參數先算成範式（見第 ref sec:evaluation 節，第 pageref para:lazy-evaluation 頁）。對這些語言來說，在上述場合使用尾遞迴函數確實只使用了定額的額外空間，效果相當好。</p>
<p>但對使用惰性求值的 Haskell 來說，情況又更複雜一些 ---若以分析工具實測，我們會發現純以本章的方式寫出的 <code class='haskell'>sumAcc</code> 仍用了和串列長度成正比的記憶體空間！這是怎麼回事呢？如前所述，<code class='haskell'>sumAcc [1,2,3,4...] 0</code> 的值是 <code class='haskell'>((((0 + 1) + 2) + 3) + 4) + ...</code>.串列越長，這個式子越長。根據惰性求值的原則，Haskell 不拖到被強迫求值的最後一刻是不會將算式歸約的。因此在走訪串列的過程中，<code class='haskell'>0+1</code> 不會歸約成 <code class='haskell'>1</code>, <code class='haskell'>(0 + 1) + 2</code> 不會歸約成 <code class='haskell'>3</code>...這個大算式就這麼存放在記憶體中。直到整個串列被走訪完，<code class='haskell'>sumAcc</code> 的呼叫者要檢查其傳回值了（可能是要將它印出來，或著做樣式配對），這個大算式才又一步步被化簡成一個單一數值。</p>
<p>為改善這類情況下的效率，Haskell 提供了一些方法讓我們早點把一些數值強迫算成範式。例如在資料型別上標注某些欄位為「嚴格(strict)」的、使用內建函數 <code class='haskell'>seq</code> 將數值歸約、或甚至使用更低階、屬於特定編譯器的「無盒型別(unboxed type)」等等。對實務導向的 Haskell 編程員來說這些都是實用的技巧，只是已超出本書的範疇。</p>
<p>如果函數傳回的不是數值，而是結構化的資料，而程式語言支援惰性求值，情形又有所不同。如習題  ref ex:mapAcc  中所見，我們可用尾遞迴的方式做 <code class='haskell'>map f</code>:</p>
<div><pre class='spec'>
mapAcc f []      ys = reverse ys
mapAcc f (x:xs)  ys = mapAcc f xs (f x : ys) {-"~~."-}
</pre></div>
乍看之下，這個程式的問題似乎是需要多做一次 <code class='haskell'>reverse</code>。但這可能並不很嚴重：<code class='haskell'>reverse</code> 也可用 <code class='haskell'>revcat</code> 實作，在線性時間內完成。該定義和原歸納定義的 <code class='haskell'>map f</code> 的最大差別是：<code class='haskell'>mapAcc f</code> 需<em>等到輸入串列整個被走訪完畢後才會開始傳回第一個結果</em>。而回顧 <code class='haskell'>map f</code> 的歸納定義：<br>
<div><pre class='spec'>
map f []      = []
map f (x:xs)  = f x : map f xs {-"~~,"-}
</pre></div>
歸納狀況中，<code class='haskell'>f x : ...</code> 可在走訪到 <code class='haskell'>x</code> 時便先產生。考慮這樣的程式：<code class='haskell'>length . filter p . map f</code>。根據惰性求值，<code class='haskell'>f x : ...</code> 會立刻被 <code class='haskell'>filter</code> 與 <code class='haskell'>length</code> 接收，然後才開始計算 <code class='haskell'>map f xs</code>. 因此 <code class='haskell'>map f</code> 回傳的中間串列其實並不會被完整地產生。在大部分情況下，歸納定義的 <code class='haskell'>map f</code> 是比尾遞迴的 <code class='haskell'>mapAcc f</code> 更有效率的函數。在許多情形中，<em>早點產生部分的結果、早點讓它被使用掉</em>，會是在空間與時間上都更有效率的做法。<br>
<h3 class='subsection' >函數作為串列<id='sec:difference-list'></h3><p>既然說到串列反轉，本節延伸介紹一個相關且相當有用的技巧。回顧 <code class='haskell'>revcat</code> 的尾遞迴定義，若將最後一個參數省去，其定義可改寫成：</p>
<div><pre class='spec'>
revcat :: List a -> (List a -> List a)
revcat []      = id
revcat (x:xs)  = revcat xs . (x:) {-"~~."-}
</pre></div>
<code class='haskell'>revcat</code> 是一個傳回 <code class='haskell'>List a -> List a</code> 的函數。在基底狀況，<code class='haskell'>revcat []</code> 傳回 <code class='haskell'>id</code>.歸納狀況中，<code class='haskell'>revcat xs</code> 傳回的函數和 <code class='haskell'>(x:)</code> 組合在一起。這和 <code class='haskell'>reverse</code> 其實很像：在基底狀況，<code class='haskell'>reverse []</code> 傳回空串列 <code class='haskell'>[]</code>,歸納狀況中，<code class='haskell'>reverse (x:xs)</code> 傳回 <code class='haskell'>reverse xs ++ (x:[])</code>。好像把空串列代換成 <code class='haskell'>id</code>, 把 <code class='haskell'>(++)</code> 變成 <code class='haskell'>(.)</code>, 我們就得到 <code class='haskell'>revcat</code> 了。<br>
<p>這令我們聯想：有沒有可能把 <code class='haskell'>List a -> List a</code> 視為串列的另一種表示法，其中 <code class='haskell'>id</code> 就是空串列，而串列連接就是 <code class='haskell'>(.)</code> 呢？定義：</p>
<div><pre style='display:none'>
type DList a = List a -> List a {-"~~,"-}
</pre></div>
一個型別為 <code class='haskell'>DList a</code> 的函數 <code class='haskell'>f</code> 表示一個「尾段尚未確定」的串列 ---餵給它一個尾巴 <code class='haskell'>ys</code>, <code class='haskell'>f ys</code> 便會傳回一個真正的串列。若 <code class='haskell'>xs</code> 是一個型別為 <code class='haskell'>List a</code> 的串列， <code class='haskell'>(xs ++)</code> 便是如此的一個 <code class='haskell'>DList a</code>.要將一個 <code class='haskell'>DList a</code> 轉成 <code class='haskell'>List a</code>, 則只需將 <code class='haskell'>[]</code> 傳進去即可。下列兩個函數幫我們在這兩種表示法之間作轉換：<br>
<table>
<tr>
0.5\textwidth<td>
<div><pre style='display:none'>
toDList :: List a -> DList a
toDList xs = (xs ++) {-"~~,"-}
</pre></div>
</td>
</tr>
<tr>
0.5\textwidth<td>
<div><pre style='display:none'>
toList :: DList a -> List a
toList xs = xs [] {-"~~."-}
</pre></div>
</td>
</tr>
</table>
<p>空串列被轉換成 <code class='haskell'>([]++)</code>, 化簡一下之後確實得到了 <code class='haskell'>id</code>.「含一個單一元素 <code class='haskell'>x</code>」的 <code class='haskell'>DList</code> 可寫成 <code class='haskell'>(x:)</code> ---給任何串列，<code class='haskell'>(x:)</code> 把 <code class='haskell'>x</code> 接到其最左邊。</p>
<p>兩個 <code class='haskell'>DList a</code> 如何連接在一起呢？使用函數組合 <code class='haskell'>(.)</code>。確實，<code class='haskell'>(xs++) . (ys ++)</code> 是一個接收任一個尾段 <code class='haskell'>ws</code>, 傳回 <code class='haskell'>xs ++ (ys ++ ws)</code> 的函數。<code class='haskell'>DList</code> 版本的 <code>cons'' 建構元則可定義成
% 我們可定義 |DList| 版本的空串列與<code>cons'' 建構元如下：</p>
<table>
<tr>
0.5\textwidth<td>
<div><pre style='display:none'>
nil :: DList a
nil = id {-"~~,"-}
</pre></div>
</td>
</tr>
<tr>
0.5\textwidth<td>
<div><pre style='display:none'>
cons :: a -> DList a -> DList a
cons x xs = (x:) . xs {-"~~."-}
</pre></div>
</td>
</tr>
</table>
<p><code class='haskell'>List</code> 上的 <code class='haskell'>(++)</code> 若往左結合，效率會較不好。例如 <code class='haskell'>(xs ++ ys) ++ zs</code> 會需要把 <code class='haskell'>xs</code> 走訪兩次。<code class='haskell'>DList</code> 的情況呢？考慮 <code class='haskell'>((xs ++) . (ys ++)) . (zs ++)</code>，其中左邊的兩個 <code class='haskell'>DList</code> 被括在一起。我們演算看看給了一個尾端 <code class='haskell'>ws</code> 後的情況：</p>
<div><pre class='spec'>
     ((xs ++) . (ys ++)) . (zs ++) $ ws
===    {- |(.)| 之定義 -}
     (xs ++) . (ys ++) $ zs ++ ws
===    {- |(.)| 之定義 -}
     (xs ++) $ ys ++ (zs ++ ws)
===  xs ++ (ys ++ (zs ++ ws)) {-"~~."-}
</pre></div>
由於 <code class='haskell'>(.)</code> 的定義，即使 <code class='haskell'>(xs ++) . (ys ++)</code> 先被組合在一起，我們仍得到括號往右括的 <code class='haskell'>xs ++ (ys ++ (zs ++ ws))</code>！<br>
<p>我們多研究一個例子。在習題  ref ex:ETree-tips  中，給定一個 <code class='haskell'>ETree a</code>, 我們想傳回其所有的標記。如果寫成 <code class='haskell'>tips (Bin t u) = tips t ++ tips u</code>，當樹往左邊傾斜時，程式會需要 $O(n^2)$ 的時間。但如果我們改用 <code class='haskell'>DList</code>:</p>
<div><pre class='spec'>
tipsD :: ETree a -> DList a
tipsD (Tip x)    = (x:)
tipsD (Bin t u)  = tipsD t . tipsD u {-"~~."-}
</pre></div>
上述函數會邊走訪輸入的樹，邊產生一個結構與輸入樹相同的 <code class='haskell'>DList</code>。例如，考慮如下的樹：<br>
<div><pre class='spec'>
t = Bin  (Bin  (Bin (Tip 5) (Tip 4))
               (Bin (Tip 3) (Tip 2)))
         (Tip 1){-"~~,"-}
</pre></div>
<code class='haskell'>tipsD t</code> 將會是 <code class='haskell'>(((5:). (4:)) . ((3:) . (2:))) . (1:)</code> -- 結構和 <code class='haskell'>t</code> 相同，只是將 <code class='haskell'>t</code> 的每個 <code class='haskell'>Tip x</code> 代換成 <code class='haskell'>(x:)</code>, 每個 <code class='haskell'>Bin</code> 代換成 <code class='haskell'>(.)</code>.但當我們傳一個空串列進去，這個由 <code class='haskell'>(x:)</code> 和 <code class='haskell'>(.)</code> 形成的「樹」將被走訪一遍，並在線性時間內得到 <code class='haskell'>5:4:3:2:1:[]</code>。事實上，如果我們為 <code class='haskell'>tipsD</code> 補一個參數並展開，我們將得到和習題  ref ex:ETree-tipsAcc  中一樣的結果。有了 <code class='haskell'>tipsD</code>, 我們可將原有的 <code class='haskell'>tips</code> 改定義為 <code class='haskell'>tips = toList . tipsD</code>, 或著 <code class='haskell'>tips t = tipsD t []</code>.<br>
<p> citet Hughes:86:Novel </p>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b><id='ex:deepestAux'>
<p>在習題  ref ex:deepest  中，我們使用組對可能得到一個型別為 <code class='haskell'>ETree a -> (List a, Nat)</code> 的函數。該函數仍需要 $O(n^2)$ 的時間連接串列（其中 $n$ 為輸入樹的大小）。請設計一個 $O(n)$ 的演算法。</p>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>假設習題  ref ex:deepest  中推導出的函數為<code class='haskell'>dd :: ETree a -> (List a, Nat)</code>. 我們定義：</p>
<div><pre class='spec'>
ddD :: ETree a -> (DList a, Nat)
ddD t = let (xs, n) = dd t in ((\zs -> xs++zs), n) {-"~~."-}
</pre></div>
有了 <code class='haskell'>ddD</code> 後，我們可改定義 <code class='haskell'>dd t = let (f, n) = ddD t in (f [], n)</code>.<br>
<p>試著推導 <code class='haskell'>ddD</code> 的歸納定義，不難得到 <code class='haskell'>ddD (Tip x) = ((x:), 0)</code>.考慮 <code class='haskell'>ddD (Bin t u)</code>, 為計算方便將 <code class='haskell'>dd</code> 改寫為 <code class='haskell'>if</code>-<code class='haskell'>then</code>-<code class='haskell'>else</code> 之形式：</p>

<div><pre style='display:none'>
-- ddDBin :: a -> (List a -> List a, Int)
ddDBin t u =
</pre></div>
 <div><pre style='display:none'>
      ddD (Bin t u)
 ===    {- |ddD| 之定義 -}
      let (xs, n) = dd (Bin t u) in ((xs++), n)
 ===    {- |dd| 之定義 -}
      let  (xs, m) = dd t
           (ys, n) = dd u
      in (  ((if m < n then xs else if m == n then xs ++ ys else ys)++),
            1 + (m `max` n))
 ===    {- 函數應用分配入 |if| -}
      let  (xs, m) = dd t
           (ys, n) = dd u
      in (  if m < n then (xs++) else if m == n then (xs ++ ys ++) else (ys++),
            1 + (m `max` n))
 ===    {- 抽出 |(xs++)| 與 |(ys++)| -}
      let  (f, m) = (let (xs, m) = dd t in ((xs++), m))
           (g, n) = (let (ys, n) = dd u in ((ys++), n))
      in (  if m < n then f else if m == n then f . g else g,
            1 + (m `max` n))
 ===    {- |ddD| 之定義 -}
      let  (f, m) = ddD t
           (g, n) = ddD u
      in (  if m < n then f else if m == n then f . g else g,
            1 + (m `max` n)) {-"~~."-}
</pre></div>
因此我們得到：<br>
<div><pre style='display:none'>
ddD (Tip x)    = ((x:), 0)
ddD (Bin t u)  | m <  n  = (f, 1 + n)
               | m == n  = (f . g, 1 + n)
               | m >  n  = (g, 1 + m) {-"~~,"-}
  where ((f,m),(g,n)) = (ddD t, ddD u) {-"~~."-}
</pre></div>
</div>
</div>
<h2 class='section' >區段問題<id='sec:segment-problems'></h2><p>一個串列中<em>連續</em>的任意一截被稱作一個「區段」(segment)。 index list 串列!segment 區段 例如，<code class='haskell'>[1,2,3]</code> 的區段包括<code class='haskell'>[]</code>,<code class='haskell'>[1]</code>,<code class='haskell'>[2]</code>,<code class='haskell'>[3]</code>,<code class='haskell'>[1,2]</code>,<code class='haskell'>[2,3]</code>, 以及<code class='haskell'>[1,2,3]</code>本身（注意：空串列也是一個區段）。也許因為歷史因素，許多有趣的演算法問題有這樣的形式：給定一個串列 <code class='haskell'>xs :: List A</code>，一個述語 <code class='haskell'>p :: List A -> Bool</code>, 和一個函數 <code class='haskell'>f :: List A -> B</code>，我們想在 <code class='haskell'>xs</code> 的所有區段中，找出滿足述語 <code class='haskell'>p</code> 並使得 <code class='haskell'>f</code> 值最大的那個。我們把這類問題統稱為「區段問題」。</p>
<p>本節討論一些簡單的區段問題。我們先回顧一下區段的形式定義。第 ref sec:list-segments 節曾提及，下述函數 <code class='haskell'>segments</code> 算出一個串列的所有區段：</p>
<div><pre style='display:none'>
segments :: List a -> List (List a)
segments = concat . map inits . tails {-"~~."-}
</pre></div>
其中 <code class='haskell'>tails :: List a -> List (List a)</code> 計算一個串列所有的後段(suffixes)，例如 <code class='haskell'>tails [1,2,3] =</code><code class='haskell'>[[1,2,3],[2,3],[3],[]]</code>； index list 串列!suffix 後段 函數 <code class='haskell'>inits :: List a -> List (List a)</code> 則計算一個串列的所有前段(prefixes)，例如 <code class='haskell'>inits [1,2,3] = [[],[1],[1,2],[1,2,3]]</code>.  index list 串列!prefix 前段 對每一個後段，計算所有的前段，便得到所有的區段了。<p class='footer'>我們也可以反過來，定義 <code class='haskell'>segments = concat . map tails . inits</code>. 本節中的所有推導與證明可調整成相對應的版本。</p>事實上，如此的定義之下 <code class='haskell'>segments [1,2,3]</code> 會將空串列傳回很多次。不過以本章的目的而言，我們對這些重複的 <code class='haskell'>[]</code> 並不在意。<br>
<p>為方便讀者，我們將 <code class='haskell'>inits</code> 與 <code class='haskell'>tails</code> 的歸納定義重複如下。</p>
<table>
<tr>
0.5\textwidth<td>
<div><pre class='spec'>
inits :: List a -> List (List a)
inits []      = [[]]
inits (x:xs)  = [] : map (x:) (inits xs) {-"~~,"-}
</pre></div>
</td>
</tr>
<tr>
0.5\textwidth<td>
<div><pre class='spec'>
tails :: List a -> List (List a)
tails []      = [[]]
tails (x:xs)  = (x:xs) : tails xs {-"~~."-}
</pre></div>
</td>
</tr>
</table>
<h3 class='subsection' >最大區段和<id='sec:maximum-segment-sum'></h3><p>給定一個串列。請問它的眾多區段中，總和最大的和是多少？這個<em>最大區段和</em>(<em>maximum segment sum</em>) index maximum segment sum 最大區段和 問題可說是最經典的區段問題。我們可將其寫成如下的規格：</p>
<div><pre style='display:none'>
mss :: List Int -> Int
mss = maximum . map sum . segments {-"~~,"-}
</pre></div>
這幾乎便是問題的字面翻譯：算出所有的區段，對每個區段算其和，然後挑出最大的一個。<p class='footer'>函數 <code class='haskell'>maximum :: List Int -> Int</code> 的定義見例 ref ex:maximumP . 我們得假設整數中有個 <code class='haskell'>-infty</code> 作為 <code class='haskell'>maximum []</code> 的結果。若要避免 <code class='haskell'>-infty</code>，可注意到 <code class='haskell'>inits</code>, <code class='haskell'>tails</code>, 和 <code class='haskell'>segments</code> 都不會傳回空串列 --- 它們的型別都可寫成更嚴格的 <code class='haskell'>ListP (List a)</code>。因此我們可改用例 ref ex:maximumP 中的 <code class='haskell'>maximumP</code>. 本節的推導稍加修改後即可適用。</p>當輸入串列長度為 $n$, 這個定義本身是一個時間複雜度為 $O(n^3)$ 的演算法 --- 該串列的區段有 $O(n^2)$ 個，每個都需分別算總和。我們能導出一個更快的演算法嗎？<br>
%format infty = "\infty"<br>22
前段-後段分解 許多區段問題的推導都以如下方式開頭：將 <code class='haskell'>segments</code> 展開成 <code class='haskell'>inits</code> 與 <code class='haskell'>tails</code>, 並將 <code class='haskell'>maximum</code> 往右推，與 <code class='haskell'>inits</code> 放在一起：<br>

<div><pre style='display:none'>
mssDer1 :: List Int -> Int
mssDer1 =
</pre></div>
 <div><pre style='display:none'>
      maximum . map sum . segments
 ===  maximum . map sum . concat . map inits . tails
 ===   {- |map f . concat = concat . map (map f)| (習題 \ref{ex:map-concat}) -}
      maximum . concat . map (map sum) . map inits . tails
 ===   {- |maximum . concat = maximum . map maximum| -}
      maximum . map maximum . map (map sum) . map inits . tails
 ===   {- |map| 融合 （定理\ref{thm:map-fusion}） -}
      maximum . map (maximum . map sum . inits) . tails {-"~~."-}
</pre></div>
細看 <code class='haskell'>maximum . map sum . inits</code> 這個子算式，其意思是「給定一個串列，計算其所有<em>前段</em>的和的最大值」。我們為這個子算式取個名字，令 <code class='haskell'>mps = maximum . map sum . inits</code>，其中 <code class='haskell'>mps</code> 為「最大前段和 maximum prefix sum」的縮寫。經由上述演算，我們得知<br>
<div><pre class='spec'>
  mss = maximum . map mps . tails {-"~~,"-}
</pre></div>
意思是：要找出所有區段的最大和，我們可以對<em>每一個後段，找出其最大前段和</em>。<br>
<p>這是解許多區段問題的常見模式：要解決最佳區段問題，先試著解最佳前段問題。要算出最佳區段，可<em>對每一個後段，算出其最佳前段</em>。<p class='footer'>反過來當然也可以。如果我們定義 <code class='haskell'>segments = concat . map tails . inits</code>, 此處的策略就變成「對每個前段，算出其最佳後段」。</p></p>
使用掃描引理 接下來我們注意到 <code class='haskell'>map mps . tails</code> 這個子算式。回顧第  ref sec:sum-scan-lemma  節的掃描引理。如果 <code class='haskell'>mps</code> 能被寫成  eqref eq:f-fold-scan  的形式：<br>
<div><pre class='spec'>
mps []      = e
mps (x:xs)  = x `oplus` mps xs {-"~~,"-}
</pre></div>
那麼我們就有了只把 <code class='haskell'>oplus</code> 呼叫 <code class='haskell'>n</code> 次便計算出 <code class='haskell'>map mps . tails</code> 的方法。這是可能的嗎？我們推導看看。<br>
<p>基底狀況很容易算出：<code class='haskell'>mps [] =</code> <code class='haskell'>(maximum . map sum . inits) [] =</code><code class='haskell'>maximum [0] = 0</code>. 考慮歸納情況：</p>

<div><pre style='display:none'>
msiDer2 x xs =
</pre></div>
 <div><pre style='display:none'>
      maximum . map sum . inits $ (x:xs)
 ===    {- |inits| 之定義 -}
      maximum . map sum $ ([] : map (x:) (inits xs))
 ===    {- |map| 之定義 -}
      maximum (sum [] : map sum (map (x:) (inits xs)))
 ===    {- |sum| 與 |maximum| 之定義, |map| 融合 -}
      0 `max` maximum (map (sum . (x:)) (inits xs))
 ===    {- |sum| 之定義 --- |sum . (x:) = (x+) . sum| -}
      0 `max` maximum (map ((x+) . sum) (inits xs))
 ===    {- |maximum . map (x+) = (x+) . maximum| -}
      0 `max` (x + maximum (map sum (inits xs))) {-"~~."-}
</pre></div>
果然成功了！我們得到：<br>
<div><pre style='display:none'>
mps []      = 0
mps (x:xs)  = 0 `max` (x + mps xs) {-"~~."-}
</pre></div>
令 <code class='haskell'>x `oplus` y = 0 `max` (x + y)</code>, 函數 <code class='haskell'>mps</code> 便符合我們要求的模式了。此處 <code class='haskell'>oplus</code> 是一個只需常數時間的函數。因此，我們將有一個能在線性時間內計算最大區段和的演算法！<br>
<p>以上計算完全依照我們所說的原則：將定義展開、然後試圖將 <code class='haskell'>maximum</code> 與 <code class='haskell'>map sum</code> 往右推直到與 <code class='haskell'>inits xs</code> 相接，以便將 <code class='haskell'>mps</code> 的定義收回。前幾步只是簡單地展開定義並使用 <code class='haskell'>map</code> 融合。最後一步中，為了將 <code class='haskell'>maximum</code> 往右推，使用了如下的性質</p>
<div><code class='haskell'><id='eq:max-mapadd'>
  |maximum . map (x+)|&|= (x+) . maximum| \mbox{~~.}
</code></div>
<p>在  eqref eq:max-mapadd  的左手邊，我們將一個串列的每個元素都加上 <code class='haskell'>x</code>, 然後取最大值。性質  eqref eq:max-mapadd  告訴我們，其實我們可以先取最大值，然後做一個加法即可。這個步驟允許我們在每一步省下了 $O(n)$ 個加法，是使得整個演算法之所以能加速的關鍵一步。而  eqref eq:max-mapadd  的證明只需使用例行的歸納法，但其中的關鍵一步需要如下的分配律：</p>
<div><code class='haskell'><id='eq:plus-max'>
|x + (y `max` z)| &|= (x + y) `max` (x + z)| \mbox{~~.}
</code></div>
<p>加法與<code class='haskell'>max</code>的分配率是使我們能有一個線性時間演算法的關鍵性質。</p>
<p>藉由程式推導，我們不僅找到了一個較快的演算法，也找出了使得該演算法之所以成立的根本性質。這使我們能輕易將該演算法推廣：除了加法與<code class='haskell'>max</code>，之外，該演算法能用在任何滿足  eqref eq:plus-max  的一組運算元之上。</p>
<div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>證明性質  eqref eq:max-mapadd 。</p>
</div>
</div>
線性時間、常數空間 根據之前的演算，我們得到：\label{code:mpsAll}<br>
%{
%format mss' = mss<br>22
<div><pre style='display:none'>
mss' :: List Int -> Int
mss' = maximum . mpsAll {-"~~,"-}

mpsAll []      =  [0]
mpsAll (x:xs)  =  let ys = mpsAll xs
                  in (0 `max` (x + head ys)) : ys {-"~~."-}
</pre></div>
%} % mss'<br>22
<p>其中 <code class='haskell'>mpsAll = map mps . tails</code>.使用掃描引理導出的 <code class='haskell'>mpss</code> 能在線性時間內對輸入串列的每個後段算出其 <code class='haskell'>mps</code> （即「最大前段和」）並存放在一個串列中。方法是將串列由右到左走訪一遍，在每一步將 <code class='haskell'>x</code> 與 <code class='haskell'>mps xs</code> 的值（存放在 <code class='haskell'>head ys</code> 中）相加，並和 <code class='haskell'>0</code> 比大小。每個 <code class='haskell'>mps</code> 值之中最大的那個，便是我們要的答案。在函數語言圈內，關於最大區段和的討論大多到此為止：我們已經有了一個漂亮的線性時間演算法了。</p>
<p>若要再挑惕，我們還有個小問題可解決：這個演算法需要線性的空間 --- <code class='haskell'>mpsAll</code> 會產生一個中間串列，由 <code class='haskell'>maximum</code> 消掉。我們有可能把 <code class='haskell'>maximum</code> 與 <code class='haskell'>mpsAll</code> 融合，得到一個不產生中間串列的演算法嗎？我們試試看：</p>

<div><pre style='display:none'>
maxmpsAllDer x xs =
</pre></div>
 <div><pre style='display:none'>
      (maximum . mpsAll) (x:xs)
 ===    {- |maximum| 與 |mpsAll| 之定義；提出 |let| -}
      let ys = mpsAll xs
      in (0 `max` (x + head ys)) `max` maximum ys
 ===  (0 `max` (x + head (mpsAll xs))) `max` maximum (mpsAll xs) {-"~~."-}
</pre></div>
雖然作出了 <code class='haskell'>maximum (mpsAll xs)</code>，但還有一個 <code class='haskell'>head (mpsAll xs)</code> 無法消掉。<br>
<p>這時就用得上<em>組對</em>的技巧了 --- 既然需要 <code class='haskell'>head (mpsAll xs)</code>，就把它一併歸納地算出來。定義：</p>

<div><pre style='display:none'>
maxhd xs = (maximum xs, head xs)
</pre></div>
 <div><pre class='spec'>
  msps xs = (maximum (mpsAll xs), head (mpsAll xs)) {-"~~,"-}
</pre></div>
藉由簡單的展開-收回，我們可推導出：<br>
%{
%format mss'' = mss<br>22
<div><pre style='display:none'><id='code:msps'>
msps :: List Int -> (Int :* Int)
msps []      =  (0,0)
msps (x:xs)  =  let  (m,s) = msps xs
                in   ((0 `max` (x + s)) `max` m, 0 `max` (x + s)) {-"~~,"-}

mss'' = fst . msps {-"~~."-}
</pre></div>
%} %mss''<br>22
<p>這是一個使用線性時間、常數空間計算最大區段和的演算法。當 <code class='haskell'>(z,y) = msps xs</code>, <code class='haskell'>z</code> 是 <code class='haskell'>xs</code> 的最大區段和，<code class='haskell'>y</code> 則是 <code class='haskell'>xs</code> 的最大前段和。每考慮一個新元素 <code class='haskell'>x</code>, 最大前段和被更新為 <code class='haskell'>0 `max` (x + y)</code> --- 如果把 <code class='haskell'>x</code> 接上後仍是正數，<code class='haskell'>x+y</code> 就是最好的前段和，否則最大前段和是空串列的和 <code class='haskell'>0</code>.新的最大前段和再與 <code class='haskell'>z</code> 比較，得到新的最大區段和。</p>
<p>第  ref sec:maximum-segment-sum-foldr  節中將用稍抽象一些的定理解最大區段和問題。</p>
<div class = 'infobox'>
{指令式版本的最大區段和}<br>11

%{
%format x0
%format xN1 = "\Varid{x}_{N-1}"
%format do = "\mathbf{do}"
%format od = "\mathbf{od}"<br>22
<p> 根據第 ref sec:tail-recursion 節的討論，當輸入串列<code class='haskell'>[x0..xN1]</code> 被逆向存放在陣列 <code class='haskell'>X</code> 之中，函數 <code class='haskell'>msps</code> 相當於以下的指令式程式：</p>
<div><pre class='spec'><id='code:mss:imperative'>
i, m, s := 0, 0, 0;
do i /= N ->  s := 0 `max` (X i + s) ;
              m := m `max` s ;
              i := i + 1
od ;
return m
</pre></div>
<p> 這在指令式程式推導的領域中也是一個經典範例。</p>
%} %GCL<br>22
</div><div class = 'exlist'>

<div class = 'Exercise'>
<b>練習:</b>
<p>由 <code class='haskell'>msps xs = (maximum (mpsAll xs), head (mpsAll xs)) </code> 開始，推導出 <code class='haskell'>msps</code> 的歸納定義。</p>
</div>
<div class = 'Answer'>
<b>答:</b>
<p>顯然 <code class='haskell'>msps [] = (0,0)</code>. 考慮 <code class='haskell'>msps (x:xs)</code>:</p>

<div><pre style='display:none'>
mspsDer1 x xs =
</pre></div>
 <div><pre style='display:none'>
      (maximum (mpsAll (x:xs)), head (mpsAll (x:xs)))
 ===    {- |mpsAll| 之定義；將 |let| 往外提 -}
      let ys = mpsAll xs
      in (maximum (0 `max` (x + head ys):ys), 0 `max` (x + head ys))
 ===    {- |maximum| 之定義 -}
      let ys = mpsAll xs
      in ((0 `max` (x + head ys)) `max` maximum ys, 0 `max` (x + head ys))
 ===    {- 將 |maximum ys| 與 |head ys| 提出 -}
      let (m, s) = (maximum (mpsAll xs), head (mpsAll xs))
      in ((0 `max` (x + s)) `max` m, 0 `max` (x + s))
 ===    {-|msps| 之定義 -}
      let (m, s) = msps xs
      in ((0 `max` (x + s)) `max` m, 0 `max` (x + s)) {-"~~."-}
</pre></div>
因此我們便推導出了第 ref sec:maximum-segment-sum 節中的 <code class='haskell'>msps</code>.<br>
</div>
</div>
<h3 class='subsection' >最長高原問題</h3>%format initsP = "\Varid{inits}^{+}"
%format tailsP = "\Varid{tails}^{+}"
%format segmentsP = "\Varid{segments}^{+}"<br>22
<p>如果一個區段的每個元素都相等，我們稱之為一個「高原(plateau)」。本節考慮這個問題：給一個串列，找出其中最長的高原的長度。例如當輸入為 <code class='haskell'>[2,3,3,2,2,2,1,6,6]</code> 時，輸出應為 <code class='haskell'>3</code> --- 即最長的高原 <code class='haskell'>[2,2,2]</code> 的長度。以下是本問題的一種可能的規格寫法：</p>
<div><pre style='display:none'>
lp :: List Int -> Int
lp = maximum . map length . filter plateau . segmentsP {-"~~,"-}
</pre></div>
其中 <code class='haskell'>segmentsP</code> 算出所有的區段，<code class='haskell'>plateau</code> 判斷一個區段是否為高原。過濾出所有的高原後，我們計算每個高原的長度，然後找出最大值。<p class='footer'>函數 <code class='haskell'>lp</code> 與 <code class='haskell'>plateau</code> 可以有更通用的型別 <code class='haskell'>Eq a => List a -> Int</code>, <code class='haskell'>Eq a => List a -> Bool</code>.</p><br>
<p>函數 <code class='haskell'>segmentsP</code> 和 <code class='haskell'>segments</code> 類似，其定義為：</p>
<div><pre style='display:none'>
segmentsP :: List a -> List (ListP a)
segmentsP = concat . map initsP . tailsP {-"~~,"-}
</pre></div>
函數 <code class='haskell'>initsP</code> 與 <code class='haskell'>tailsP</code> 則與 <code class='haskell'>inits</code> 與 <code class='haskell'>tails</code> 類似，但只傳回非空的前後段，定義如下：<br>
<table>
<tr>
0.5\textwidth<td>
<div><pre style='display:none'>
initsP :: List a -> List (ListP a)
initsP []      = []
initsP (x:xs)  = [x] : map (x:) (initsP xs) {-"~,"-}

</pre></div>
</td>
</tr>
<tr>
0.5\textwidth<td>
<div><pre style='display:none'>
tailsP :: List a -> List (ListP a)
tailsP []      = []
tailsP (x:xs)  = (x:xs) : tailsP xs {-"~~."-}
</pre></div>
</td>
</tr>
</table>
<p>以上三個函數的回傳型別都是 <code class='haskell'>List (ListP a)</code> ---每個傳回的前/後/區段都是非空的，但並非每個串列都有非空的前/後/區段。函數 <code class='haskell'>lp</code> 仍可接受空串列作為輸入，但（我們等下將看到）在規格中使用 <code class='haskell'>segmentsP</code> 將帶來不少方便。我們也可使用 <code class='haskell'>segment</code> 定最長平原問題的規格，只是會增加一些不利於講解的細節。</p>
<p>函數 <code class='haskell'>plateau</code> 可定義如下：</p>
<div><pre style='display:none'>
plateau :: ListP Int -> Bool
plateau [x]       = True
plateau (x:y:xs)  = x == y && plateau (y:xs) {-"~~."-}
</pre></div>
由於輸入是非空串列，<code class='haskell'>plateau</code> 的定義中考慮的是「有一個元素」和「有兩個以上元素」的兩種情況。<br>
<div class = 'infobox'>
{區段問題不傳回區段？}<br>11

<p> 為何我們在最大區段和問題中只傳回最大區段的和、在最長高原問題中只傳回長度，而不傳回該區段本身呢？</p>
<p> \quad 這是許多演算法題目常見的簡化：當真正的問題是尋找「使得某值最大的聚合資料結構」時，我們常只要求解題者傳回該值，而不是整個聚合資料結構。如此做的好處之一是讓我們能暫時忽略「如何組出需傳回的資料結構」的細節，更專注在問題本身。這使得問題的規格與推導過程都簡單許多。</p>
<p> \quad 如果我們真的需要整個區段，我們總能將前述的簡單版程式擴充為傳回資料結構的程式。讀者不妨試試能否將第  pageref code:mpsAll  頁的 <code class='haskell'>mpsAll</code> 改寫為型別為<code class='haskell'>List Int -> List (Int :* List Int)</code> 的程式 --- 對每個後段，計算其<em>最佳前段和，以及該前段</em>。您會發現程式結構並沒有改變，只是多了些繁瑣的細節。</p>
<p> \quad 另一個理由是：具有最大和的區段可能不只一個。在<em>函數</em>程式推導之中，如果我們要傳回區段，由於規格也是函數，我們似乎必須在規格中就決定傳回哪一個。若希望規格是「傳回<em>任一個</em>具有最大和的區段」，我們會需要更多機制，例如使用<em>關係</em>(<em>relation</em>)或使用單子。</p>
</div>前段-後段分解 和最大區段和問題一樣，我們先嘗試把這個區段問題分解為「對每個後段，計算最佳前段」：<br>

<div><pre style='display:none'>
lppDer1 :: List Int -> Int
lppDer1 =
</pre></div>
 <div><pre style='display:none'>
      maximum . map length . filter plateau . segmentsP
 ===  maximum . map length . filter plateau . concat . map initsP . tailsP
 ===     {- 因 |filter p . concat = concat . map (filter p)| -}
      maximum . map length . concat . map (filter plateau . initsP) . tailsP
 ===     {- 因  |map f . concat = concat . map (map f)|, |map| 融合 -}
      maximum . concat . map (map length . filter plateau . initsP) . tailsP
 ===     {- 因 |maximum . concat = maximum . map maximum|, |map| 融合 -}
      maximum . map (maximum . map length . filter plateau . initsP) . tailsP {-"~~."-}
</pre></div>
嘗試使用掃描引理 下一步：我們把 <code class='haskell'>maximum . map length . filter plateau . initsP</code> 簡寫為 <code class='haskell'>lpp</code>，並嘗試將它寫成  eqref eq:f-fold-scan  的形式，以便使用掃描引理。演算如下：<br>

<div><pre style='display:none'>
lppDer2 :: Int -> List Int -> Int
lppDer2 x xs =
</pre></div>
 <div><pre style='display:none'>
      (maximum . map length . filter plateau . initsP $ (x:xs))
 ===  (maximum . map length . filter plateau $ [x] : map (x:) (initsP xs))
 ===    {- |filter| 之定義，|plateau [x] = True| -}
      maximum (1 : map length (filter plateau (map (x:) (initsP xs))))
 ===  1 `max` maximum (map length (filter plateau (map (x:) (initsP xs)))) {-"~~."-}
</pre></div>
%format &&: = "\mathbin{\dot{\wedge}}"<br>22
<p>演算至此的問題是：如何把 <code class='haskell'>map (x:)</code> 提出來呢？定理 ref thm:filter-map 允許我們把 <code class='haskell'>map</code> 搬到 <code class='haskell'>filter</code> 的左邊：</p>
<div><pre class='spec'>
 filter p . map f = map f . filter (p . f) {-"~~."-}
</pre></div>
至於 <code class='haskell'>plateau . (x:)</code> 能否再化簡？觀察 <code class='haskell'>plateau</code> 定義的第二個子句：<br>
<div><pre class='spec'>
plateau (x:y:xs)  = x == y && plateau (y:xs) {-"~~,"-}
</pre></div>
寫成函數組合的形式便是：<br>
<div><pre class='spec'>
plateau . (x:) = ((x ==) . head) &&: plateau {-"~~,"-}
</pre></div>
其中 <code class='haskell'>(&&:)</code> 為「提升成函數版」的 <code class='haskell'>(&&)</code>, 定義為<br>
<div><pre style='display:none'>
(&&:) :: (a -> Bool) -> (a -> Bool) -> a -> Bool
(f &&: g) x = f x && g x {-"~~."-}
</pre></div>
函數 <code class='haskell'>(&&) :: Bool -> Bool -> Bool</code> 拿兩個布林值、算出一個新布林值，<code class='haskell'>(&&:)</code> 則拿兩個函數 <code class='haskell'>f, g :: a -> Bool</code>，組合成另一個型別為 <code class='haskell'>a -> Bool</code> 的函數，其結果是 <code class='haskell'>f</code> 與 <code class='haskell'>g</code> 之傳回值的合取。函數 <code class='haskell'>filter</code> 與 <code class='haskell'>(&&:)</code> 有如下的性質：<br>
<div><code class='haskell'><id='eq:filter-conjunct'>
  |filter (p &&: q)| & |= filter p . filter q| \mbox{~~.}
</code></div>
有了以上眾多性質，我們演算如下：<br>

<div><pre style='display:none'>
lppDer3 :: Int -> List (List Int) -> List (ListP Int)
lppDer3 x =
</pre></div>
 <div><pre style='display:none'>
      filter plateau . map (x:)
 ===    {- 定理 \ref{thm:filter-map} -}
      map (x:) . filter (plateau . (x:))
 ===    {- |plateau| 之定義 -}
      map (x:) . filter (((x ==) . head) &&: plateau)
 ===    {- 因 \eqref{eq:filter-conjunct}: |filter (p &&: q) = filter p . filter q| -}
      map (x:) . filter plateau . filter ((x ==) . head) {-"~~."-}
</pre></div>
現在整個式子成為 <code class='haskell'>1 `max` (maximum . map (length . (x:)) . filter plateau . filter ((x ==) . head) . initsP) $ xs</code>.<br>
<p>把 <code class='haskell'>map (x:)</code> 往左搬之後，式子的右邊出現了 <code class='haskell'>filter ((x ==) . head) (initsP xs)</code> --- 產生所有 <code class='haskell'>xs</code> 的非空前段，取出第一個元素為 <code class='haskell'>x</code> 的。但讀者們可能立刻發現：<code class='haskell'>initsP</code> 傳回的每個前段的第一個元素都是一樣的！也就是說我們有以下性質。</p>
\begin{flalign}
\qquad\quad
\begin{split}
&  |filter ((x==) . head) (initsP xs) =|\\
&\qquad   |if x == head xs then initsP xs else [] {-"~~."-}|
\end{split} &
\label{eq:initsP-heads}
\end{flalign}<br>22
<p>考慮非空前段的好處在這兒可看出：<code class='haskell'>head</code> 對非空串列才有值。</p>
<p>回到 <code class='haskell'>lpp</code>，我們可繼續推導如下：</p>

<div><pre style='display:none'>
lppDer4 :: Int -> List Int -> Int
lppDer4 x xs =
</pre></div>
 <div><pre style='display:none'>
      lpp (x : xs)
 ===   {- 前述演算, |map| 融合 -}
      1 `max`  (maximum . map (length . (x:)) . filter plateau .
                  filter ((x ==) . head) . initsP $ (x : xs))
 ===   {- 因 \eqref{eq:initsP-heads} -}
      1 `max`  (maximum . map (length . (x:)) . filter plateau $
                  if x == head xs then initsP xs else [])
 ===   {- \eqref{eq:fn-if-distribute}: 函數分配進 |if| -}
      if x == head xs
        then 1 `max`  (maximum . map (length . (x:)) . filter plateau . initsP $ xs)
        else 1 `max` (maximum . map (length . (x:)) . filter plateau $ [])
 ===   {- |length . (x:) = (1+) . length|, 及其他化簡 -}
     if x == head xs
        then 1 + (maximum . map length . filter plateau . initsP $ xs)
        else 1
 ===   {- |lpp| 之定義 -}
     if x == head xs then 1 + lpp xs else 1 {-"~~."-}
</pre></div>
由此我們得到<br>
<div><pre style='display:none'>
lpp [x]     = 1
lpp (x:xs)  = if x == head xs then 1 + lpp xs else 1 {-"~~."-}
</pre></div>
然而，我們雖為 <code class='haskell'>lpp</code> 推導出了一個歸納定義，該定義並不符合  eqref eq:f-fold-scan ！後者要求 <code class='haskell'>lpp</code> 的右手邊必須是 <code class='haskell'>x `oplus` lpp xs</code> 的形式 --- 在 <code class='haskell'>lpp xs</code> 之外不能有其他的 <code class='haskell'>xs</code>, 而上述的 <code class='haskell'>lpp</code> 右手邊多了一個 <code class='haskell'>head xs</code>.<br>
<p>這時組對的技巧又派上用場了。定義：</p>
<div><pre class='spec'>
lpph xs = (lpp xs, head xs) {-"~~,"-}
</pre></div>
我們可推導出<br>
<div><pre style='display:none'>
lpph [x]     = (1, x)
lpph (x:xs)  = (if x == y then 1 + n else 1, x) {-"~~,"-}
   where (n,y) = lpph xs {-"~~."-}
</pre></div>
該函數符合  eqref eq:f-fold-scan  的形式，其中 <code class='haskell'>e = (1,x)</code>, <code class='haskell'>x `oplus` (y,n) = (if x == y then 1 + n else 1, x)</code>.<br>
總結 綜合目前為止的推導，函數 <code class='haskell'>lpp</code> 的推導大架構如下：<br>

<div><pre style='display:none'>
lppDer5 :: Int -> List Int -> Int
lppDer5 x =
</pre></div>
 <div><pre style='display:none'>
      lpp
 ===    {- 前段-後段分解 -}
      maximum . map (maximum . map length . filter plateau . initsP) . tailsP
 ===    {- 前述演算：尋找歸納定義 -}
      maximum . map lpp . tailsP
 ===    {- 因 |lpp = fst . lpph|  -}
      maximum . map (fst . lpph) . tailsP
 ===    {- 掃描引理 -}
      maximum . map fst . lpphAll {-"~~,"-}
</pre></div>
其中 <code class='haskell'>lpphAll</code> 的定義如下：<br>
<div><pre style='display:none'>
lpphAll [x]     = [(1,x)]
lpphAll (x:xs)  = (if x == y then 1 + n else 1, x) : (n,y) : ys {-"~~,"-}
  where ((n,y) : ys) = lpphAll xs {-"~~."-}
</pre></div>
這是一個使用線性時間、線性空間的演算法。<br>
<h2 class='section' >參考資料</h2>最大區段和  對試圖推銷程式推導的人來說，最大區段和問題幾乎有模範問題該有的一切特質：目標不難理解，但又不容易一眼看出怎麼解得快；大部分的推導過程都能用很形式化、依符號推導的方式進行；推出的程式有顯著的效率提升。程式僅需短短幾行，乍看之下卻不容易理解為何會正確。因此最大區段和問題是程式推導圈內常常提及的經典例子。<br>
<p>根據 Bentley 的 <em>Programming Pearls</em>\citep{Bentley:86:Programming} 一書，最大區段和問題最初由 Brown 大學的 Ulf Grenander 所提出。他當時正設計一個圖形配對的函式。其中，具有最大區段和的<em>二維</em>子陣列是圖形中最有可能含有指定樣式的區域。二維問題比較難解，因此他先考慮一維的情況：</p>
<blockquote>
<p>1977 年，[Grenander] 把該問題講給 UNILOGIC 公司的 Michael Shamos 聽，後者一夜之間就設計出了<b>演算法3</b>.Shamos 不久後告訴我這個問題時，我們都認為那大概就是最好的解法了；...又幾天後，Shamos 在 Carnegie-Mellon 大學的專題討論會中講了這個問題和它的來龍去脈。當時在場的統計學家 Jay Kadane 一聽，幾分鐘內就設計出了<b>演算法4</b>.</p>
</blockquote>
<blockquote>
<p>--- Jon Bentley, <em>Programming Pearls</em> (第一版), 第76頁.</p>
</blockquote>
<p>Kadane 的<b>演算法4</b>就是現在廣為人所知的（指令語言版）線性時間解（見第 pageref code:mss:imperative 頁）。</p>
<p>Shamos 的<b>演算法3</b>則是一個採取<em>分而治之</em>(<em>divide and conquer</em>)法的演算法：將陣列分成長度略等的兩半<code class='haskell'>xs ++ ys</code>, 分別計算 <code class='haskell'>xs</code> 與 <code class='haskell'>ys</code> 的最大區段和。但除此之外，還得考慮跨越 <code class='haskell'>xs</code> 與 <code class='haskell'>ys</code> 的區段。因此該演算法在遞迴的每一層又多用了兩個迴圈，分別計算 <code class='haskell'>xs</code> 的最大後段和與 <code class='haskell'>ys</code> 的最大前段和，兩者之和就是橫跨 <code class='haskell'>xs</code> 與 <code class='haskell'>ys</code> 的最大區段和。（見第 pageref code:mss:shamos 頁。）該演算法使用 $O(n \log n)$ 的時間。</p>
<p>事後回顧，Shamos 其實不需在每層都把最大前段與後段和重頭算起。我們可用類似組對的想法，對每個子陣列都由下至上地算出以下四個值：最大前段和、最大區段和、最大後段和，以及總和。如此一來我們可得到一個線性時間演算法。這可看作給我們的一個暗示：「分而治之」在此也許是不必要的，我們不需要把陣列從中切半。事實上，把陣列分成頭與尾反而讓事情簡化不少。Kadane 立刻想出了<b>演算法4</b>，不知是否用了同樣的思路？</p>
<p>我最初是在  citet Gibbons:97:Calculating  中見到此問題，當時便覺得印象深刻。Gibbons 的這篇文章是很好的函數程式推導簡介。 citet Bird:96:Generic  改用<em>關係</em> --- 函數的一種擴充 --- 解最大區段和問題，並推廣到其他資料結構。 citet Mu:08:Maximum  則以最大區段和問題為開端，討論一些有趣的變形：例如有長度限制的最大區段和，和最大<em>平均</em>區段。</p>
<div class = 'infobox'>
{Shamos 的最大區段和演算法}<br>11

<p> 以下是我根據個人理解將 Shamos 的<b>演算法3</b>寫成的 Python 程式。</p>
%{
%format def = "\mathbf{def}"
%format for = "\mathbf{for}"<br>22
<div><pre class='spec'><id='code:mss:shamos'>
def mss(l,u):

  if l > u:
    return 0               {-"\quad\color{burntorange}{\mbox{\# 空陣列的情況}}"-}
  else if l == u:
    return (0 `max` a[l])  {-"\quad\color{burntorange}{\mbox{\# 單一元素陣列的情況}}"-}
  else:
    m = (l + u) / 2


    {-"\color{burntorange}{\mbox{\# 計算 a[l..m] 的最大後段和}}"-}
    sum, maxToLeft = 0, 0
    for i in range (m, l-1, -1):
      sum = sum + a[i]
      maxToLeft = maxToLeft `max` sum


    {-"\color{burntorange}{\mbox{\# 計算 a[m+1..u] 的最大前段和}}"-}
    sum, maxToRight = 0, 0
    for i in range (m+1, u+1):
      sum = sum + a[i]
      maxToLeft = maxToRight `max` sum


    maxCrossing = maxToLeft + maxToRight


    {-"\color{burntorange}{\mbox{\# 遞迴計算 a[l..m] 與 a[m+1..u] 的最大區段和}}"-}
    maxInL = mss(l,m)
    maxInR = mss(m+1,u)


    return (maxInL `max` maxCrossing `max` maxInR)
</pre></div>
%}<br>22
</div>區段問題  citet Zantema:92:Longest <br>
</div>
</div>
</body>
</html>
