<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head>
<title>bookdownlight</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<script type="text/javascript"
    src="https://www.maths.nottingham.ac.uk/plp/pmadw/LaTeXMathML.js">
</script>
<link rel="stylesheet" href="mystyle.css">
</head>
<body class="introcontent">


<div class='main' >
    <div>
        <h1 class="container">
        <p> 程式設計：函數程式語言 </p>
        </h1>
    </div>
    <nav>
        <ul class="container">
            <li><a href="Introduction.html"> Introduction </a></li>
            <li><a href="Basics.html"> Basics </a></li>
            <li><a href="Induction.html"> Induction </a></li>
            <li><a href="Semantics.html"> Semantics </a></li>
            <li><a href="Derivation.html"> Derivation </a></li>
            <li><a href="Folds.html"> Folds </a></li>
        </ul>
    </nav>


<div class="book">
<h1 class='chapter'>符號、演算、與抽象化<id='ch:intro'></h1><p>我們先從一個故事開始。</p>
<p>一個島上住著兩種人，騎士 (knight) 與惡棍 (knave) 。騎士總說實話，惡棍總說謊話 --- 所謂「謊話」的意思是實話的相反。從外表看不出一個人是騎士或惡棍。你站在一個山洞前。傳說中，山洞盡頭藏著價值連城的黃金。但也有可能並非如此，洞裡其實是一頭龍，一進去就會被吃了。洞口站著一位老先生，看不出是騎士或是惡棍。你該如何設計一個問題問他，得知山洞裡到底有沒有金子呢？</p>
<p>我們不妨先做個熱身題。</p>
<div>example<id='eg:knight-knave-gold'><br>
<p>假設在你面前站著兩位居民，A 與 B. 居民 A 說：「如果你問 B 他自己是不是騎士，他會說是。」由此你可知道 A 是騎士或是惡棍嗎？B 呢？</p>
example</div>
<p>在讀下去之前，請先嘗試解解看。</p>
<h2 class='section' >騎士與惡棍之島</h2><p>剛剛你是怎麼解這問題的？許多人解這類問題用的是窮舉法：假設<code class='haskell'>A</code>是騎士、<code class='haskell'>B</code>也是騎士，看看會不會有矛盾，接著假設<code class='haskell'>A</code>是騎士、<code class='haskell'>B</code>是惡棍，看看是否有矛盾... 依此類推。</p>
<p>我們想介紹另一種做法。我們將「<code class='haskell'>A</code>是騎士」簡寫成<code class='haskell'>A</code>. 如果<code class='haskell'>A</code>說了某個陳述<code class='haskell'>S</code>, 我們無法知道<code class='haskell'>S</code>是否成立，但我們知道</p>
<div><pre class='spec'>
    A <=> S  {-"~~."-}
</pre></div>
其中的 <code class='haskell'>(<=>)</code> 可以理解為邏輯中「若且唯若」的關係，也可以簡單理解為（真假值的）「等於」。若用口語說，當我們寫 <code class='haskell'>P <=> Q</code>, 表示 <code class='haskell'>P</code> 和 <code class='haskell'>Q</code> 的真假值相同。確實，假定<code class='haskell'>A</code>說了陳述<code class='haskell'>S</code>，如果<code class='haskell'>A</code>是騎士，<code class='haskell'>S</code>便是真的；如果<code class='haskell'>A</code>不是騎士，<code class='haskell'>S</code>便是假的。因此「<code class='haskell'>A</code>說了陳述<code class='haskell'>S</code>」可寫成 <code class='haskell'>A <=> S</code>。<br>
<p>「若且唯若」這符號有幾個性質。首先，對任何陳述 <code class='haskell'>P</code>, 可知 <code class='haskell'>P <=> P</code> 必定為真：</p>
<div><pre class='spec'>
  (P <=> P) <=> true {-"~~."-}
</pre></div>
我們將這條規則命名為「自反恆真」。<p class='footer'>給定二元關係 <code class='haskell'><=:</code>，如果 <code class='haskell'>x <=: x</code> 對任何 <code class='haskell'>x</code> 均成立，我們說 <code class='haskell'><=:</code> 有<em>自反性</em>(<em>reflexivity</em>). index reflexivity 自反律  「自反恆真」即「自反性恆為真」的意思。</p>其次，既然 <code class='haskell'>(<=>)</code> 可以理解為「等於」，理所當然該有交換律：<p class='footer'><code class='haskell'>(<=>)</code> 和 <code class='haskell'>(=)</code> 都是「等於」。我們在此處使用不同符號，僅是為了區分出先後次序：同一行內部的相等用 <code class='haskell'>(<=>)</code>, 行與行之間的相等用 <code class='haskell'>(=)</code>. 本書其他地方的用法可能不同。</p><br>
<div><pre class='spec'>
    P <=> Q
 =  Q <=> P {-"~~."-}
</pre></div>
最後，很少人注意到，真假值的「等於」是有結合律的：對任何 <code class='haskell'>P</code>, <code class='haskell'>Q</code>, 和 <code class='haskell'>R</code>, 我們有這樣的性質：%<p class='footer'><code class='haskell'>(P <=> Q) <=> R</code> 只在 <code class='haskell'>P</code>, <code class='haskell'>Q</code>, 和 <code class='haskell'>R</code> 都是真假值（或邏輯陳述）時有意義，否則 <code class='haskell'>P</code>, <code class='haskell'>Q</code>, 和 <code class='haskell'>R</code>無法用 <code class='haskell'>(<=>)</code> 串起。反例： <code class='haskell'>(3 = 3) = 3</code> 可化簡成 <code class='haskell'>true = 3</code>, 但後式中等號兩邊的值型別不同，不是合法的句子。也許因為我們較常考慮數字的相等，而較少用符號表達真假值的相等，<code class='haskell'>(<=>)</code> 的結合律並不廣為人知。</p><br>
<div><pre class='spec'>
    (P <=> Q) <=> R
 =  P <=> (Q <=> R) {-"~~."-}
</pre></div>
<p>為了練習，我們多考慮一些情況。假設我們問<code class='haskell'>A</code>：「你是騎士嗎？」而<code class='haskell'>A</code> 回答「是的！」這可以記成<code class='haskell'>A <=> A</code>. 然而，根據自反恆真，<code class='haskell'>A <=> A</code>可以化簡為<code class='haskell'>true</code>. 這意味著：在這島上不管你問誰「你是騎士嗎」，對方都會回答「是」。</p>
<p>如果<code class='haskell'>A</code>說：「<code class='haskell'>B</code>是騎士」呢？ 這可以記成<code class='haskell'>A <=> B</code>. 由此我們無法知道<code class='haskell'>B</code>到底是騎士還是惡棍，但我們可以知道<code class='haskell'>A</code>和<code class='haskell'>B</code>是同一種人。</p>
<p>現在想想問題 ref eg:knight-knave-gold ：居民 <code class='haskell'>A</code> 說「如果你問 <code class='haskell'>B</code> 他自己是不是騎士，他會說是。」這可以記成 <code class='haskell'>A <=> (B <=> B)</code>. 我們來演算看看：</p>
<div><pre class='spec'>
   A <=> (B <=> B)
=    {- 自反恆真-}
   A <=> true
=    {- 結合律與自反恆真 -}
   A {-"~~."-}
</pre></div>
也就是說，我們不知道<code class='haskell'>B</code>到底是騎士還是惡棍，卻可知道<code class='haskell'>A</code>一定是騎士！這段演算中，把 <code class='haskell'>A <=> true</code> 換成 <code class='haskell'>A</code> 的最後一步，直覺上似乎很直觀。如果要探究理由，其實用了結合律與自反恆真：<code class='haskell'>(A <=> A) <=> true</code> 根據結合律可代換為 <code class='haskell'>A <=> (A <=> true)</code>, 因此 <code class='haskell'>A <=> true</code> 可代換成 <code class='haskell'>A</code>.<br>
<p>再考慮一個熱身題：如果<code class='haskell'>A</code>說「我和<code class='haskell'>B</code>是同一種人」呢？這可記成<code class='haskell'>A <=> (A <=> B)</code>。我們算算看:</p>
<div><pre class='spec'>
      A <=> (A <=> B)
    =   {- 結合律 -}
      (A <=> A) <=> B
    =   {- 自反恆真 -}
      true <=> B
    =   {- 交換律與自反恆真 -}
      B{-"~~."-}
</pre></div>
這次，我們不知<code class='haskell'>A</code>是騎士還是惡棍，卻可知<code class='haskell'>B</code>一定是騎士。<br>
<p>最後，我們該回到本章開頭的問題了。你站在山洞口，面對洞口的老人。姑且稱呼他為<code class='haskell'>A</code>. 要怎麼想出一個問題問他，用來判斷島上到底有沒有金子呢？之前介紹邏輯符號的目的是讓我們可避免瞎猜，而用代數解未知數的方式把問題推演出來。把「島上有金子」這個命題記為<code class='haskell'>G</code>. 我們希望問某個問題<code class='haskell'>Q</code>。如果<code class='haskell'>A</code>對問題<code class='haskell'>Q</code>回答「是」，就表示島上有金子，反之則否。</p>
<ul>
<li>
<p>「<code class='haskell'>A</code>對問題<code class='haskell'>Q</code>回答『是』」記為<code class='haskell'>A <=> Q</code>；</p>
</li>
<li>
<p>「<code class='haskell'>A</code>對問題<code class='haskell'>Q</code>回答『是』，島上便有金子」其實應該是一個若且唯若的命題，寫成<code class='haskell'>G <=> (A <=> Q)</code>。</p>
</li>
</ul>
<p>而根據交換律和結合律，我們可以推演：</p>
<div><pre class='spec'>
       G <=> (A <=> Q)
    =    {- 結合律 -}
       (G <=> A) <=> Q
    =    {- 交換律 -}
       Q <=> (G <=> A)  {-"~~."-}
</pre></div>
<p>我們可得知<code class='haskell'>Q <=> (G <=> A)</code>，也就是說我們要問<code class='haskell'>A</code>的問題<code class='haskell'>Q</code>就是<code class='haskell'>G <=> A</code>：「請問，『島上有金子』和『你是騎士』是不是等價的呢？」<p class='footer'>不妨試試看能否把這句子講得不那麼繞口？</p></p>
<p>希望這個島上不論騎士或惡棍，邏輯都蠻不錯，才聽得懂這種問題囉！</p>
<h2 class='section' >讓符號為你工作<id='sec:let-symbols-work'></h2><p>回顧看看，我們方才解各種「騎士與惡棍」問題的方法都分為兩個步驟：第一步先把情況以一組符號描述出來，第二步則是依照這些符號的規則下去推演。理想上，第二步比第一步容易，因為我們在進行推演時已不用回頭去思考這些符號的<em>意思</em>，只需照著符號本身的規則不加思索地推演。這麼的好處是能減輕我們思考的負擔。</p>
<p>探究怎樣的符號組成是合法的、一組合法的符號能否經由給定的規則轉換成另一組符號，是<em>語法</em>(<em>syntax</em>) index syntax 語法 層次上的問題。問這些符號的「意思」是什麼，則是<em>語意</em>(<em>semantics</em>) index semantics 語意 的層次。以騎士與惡棍問題為例，如果我們回到第一原則去窮舉「如果<code class='haskell'>A</code>是騎士，<code class='haskell'>B</code>也是騎士.. 如果<code class='haskell'>A</code>是惡棍，<code class='haskell'>B</code>也是惡棍 .. 」等等種種可能，這是在語意上思考。至少對這個問題來說，語意上的解法不僅較繁瑣，也只能用來回答「某人是騎士還是惡棍」類型的問題，而難以用來推演出「該如何問老人，才能得知山洞中是否有黃金？」。上一節的解法則是利用語法幫助我們：將問題寫下，利用交換律、結合律等等規則時，我們其實沒有回頭去思考「等等，這個式子是什麼意思？」但在符號的幫助之下，我們以更簡潔的方式解了許多個問題。</p>
<p>再舉一個「以符號思考」的例子：你會如何算 <code class='haskell'>28 * 18</code>? 如果你的思路是「<code class='haskell'>28</code>乘以<code class='haskell'>19</code>是<code class='haskell'>10</code>個<code class='haskell'>28</code>加上<code class='haskell'>8</code>個<code class='haskell'>28</code>，而<code class='haskell'>10</code>個<code class='haskell'>28</code>是<code class='haskell'>280</code>，<code class='haskell'>8</code>個<code class='haskell'>28</code>是... <code class='haskell'>10</code>個<code class='haskell'>28</code>減掉<code class='haskell'>2</code>個<code class='haskell'>28</code>!」那麼這種思考方式比較接近語意上的。你不斷在思考這個式子「代表什麼」，並試圖尋找較簡單的捷徑。如果你拿起紙筆，甚至在心中畫出了這樣的符號：</p>
<div><pre class='spec'>
       28
    *  17
    -----
</pre></div>
然後開始照背誦的九九乘法表去推演，此時你用的是語法式的解法。你也許不會思考許多，只以熟悉的規則推著演算的進行。以乘法而言，這兩種作法各有用處。但不可否認地，這套語法式解法的存在使我們可安心地把乘法當作<em>已經解決的</em>問題：我們可以不用思考地作乘法。<br>
<p>許多人見到數學符號就覺得難。事實上，數學符號是發明來簡化問題的。符號與符號之間的規則讓我們可僅用語法、不需在語意上思考，我們因而可把腦力用在更難的問題上。大家看到數學符號就覺得難，其實正是因為它們常被用在不靠數學符號就難以解決的難題上。難的是這些問題，而符號給了我們解決它們的能力。</p>
<p>這一切和程式語言有什麼關係呢？因為，一套好的程式語言就是一套設計良好的符號。它能幫助我們描述問題，並找出解決問題的方法。一些程式語言學者提出的口號「讓符號為你工作(let the symbols do the work!)」恰好地描述了這門學問的精神。</p>
<h2 class='section' >抽象化</h2><p>如前所述，我們解決問題的第一步是以符號將它表達出來。這一步稱作「<em>抽象化</em>(abstraction)」 index abstraction 抽象化 ，通常是較難的一步。</p>
<div>example<br>
<p>Mary 有的蘋果數目是 John 的兩倍。Mary 發現她的蘋果中有一半已經壞掉了，於是丟了它們。John 則吃了一顆蘋果。現在 Mary 有的蘋果數目仍是 John 的兩倍。請問他們最初各有多少顆蘋果？</p>
example</div>
<p>你會如何解這問題呢？如果回到第一原則，我們也許可以一步步嘗試：試試看 John 最初有一顆蘋果，Mary 有兩顆的情況是不是合理解答，然後試試看 John 有兩顆，Mary 有四顆的情況... 這是在語意上解問題。就如同我們解騎士與惡棍問題時用窮舉法一樣。</p>
<p>但許多人也許會用代數：把 Mary 最初的蘋果數目用$m$表示，John 的蘋果數目用$j$表示，寫成這樣的式子：</p>
\begin{align*}
      m &= 2j \mbox{~~,}\\
    m/2 &= 2(j-1) \mbox{~~.}
\end{align*}<br>22
接下來，用高中程度的代數方法，就可以找出$m$和$j$的值了。<br>
<p>代數方法是純粹基於語法的技術：我們觀察式子的結構，決定該怎麼作（例如把第二個式子乘以二，兩式相減；或著把$m$代換成$2j$），而不需記得$m$和$j$分別是什麼意思。</p>
<p>不需依賴「意義」在此是個重要的優點：這表示這套代數方法和特定問題的意義無關，可應用在許許多多場合。可用來解這個問題，也可用來解雞兔問題... 只要能把問題表示成代數式子，就有一個機械化、不需費神思考的解法。</p>
<p>從「Mary 有的蘋果數目是 John 的兩倍... 」到$m = 2j; m/2 = 2(j-1)$的轉變是一個「抽象化」。抽象化在此的意義是<b>將不重要的資訊拋棄，只『抽取出』此問題中最關鍵的元素</b>。由於此處我們的目的是找出「Mary與John最初各有多少顆蘋果」，我們可猜想關於數字的資訊(例如 $m = 2j$)是重要的，並猜想其他的一些資訊（蘋果是壞掉還是被吃掉了？兩人丟/吃蘋果的先後順序？）可能是不重要的。因此我們決定只留下關於數字的資訊，並幸運地確實靠此便解出了問題。</p>
<p>電腦是個只會處理符號的機器。實體世界的問題之所以能用電腦來解決，仰賴的就是「抽象化」這一步。有人說，整個計算科學就是關於抽象化的學問。</p>
<p>日常用語中，當我們說某事物「很抽象」，通常意味該事物模糊而難以理解。在計算科學中，「抽象」的事物才是最關鍵、最確實、最該把握的。我們前面才說過「數學符號讓事情變容易」，現在又說「抽象過的事物是最確實的」。看來學程式語言久了，讓我們越來越難與常人溝通。最後只好離群索居，躲到騎士與惡棍之島上捉弄來訪的遊客囉！</p>
<h2 class='section' >抽象化與表達力</h2><p>在開發較具規模的軟體前，許多軟體方法建議我們分析問題、需求，並寫成形式化的規格。<p class='footer'>例如， citet Abrial:96:B  的 B method 是以一套基於集合論與一階邏輯的形式語言描述軟體規格的方法。</p> 這是一種抽象化。面對真實的問題時，這一步不容易。</p>
<p>我們再回到蘋果的例子，回想起在該例中，我們選擇抽取出和值有關的資訊，而拋棄了許多其他：因果、先後順序... 等等。</p>
<p>在某些問題或應用中，因果或時間順序是否有可能是重要的？確實有。解這些問題時，我們可能在中途發現選錯了抽象的方式，使得留下的資訊不足以解決該問題。於是我們只好重新開始。有時，我們甚至會發現現有的符號不足以表達這些問題，得設計另一套符號。</p>
<p>這讓我們討論到解決問題重要的<em>第零步</em>：在我們能用符號表達問題之前，得先有人設計出一套完善的、足以表達許多問題的符號及其運算規則。為不同目的，我們可能設計不同的符號。一套符號也伴隨著該符號可如何轉變、操作（例如我們見過的交換律、結合律，某些符號碰在一起可化簡、等等）的規則。符號及其規則合起來成為一個「形式(formal)系統」。使用設計過的符號與其規則解決問題的研究被稱作「形式方法(formal method)」。此處的 "formal" 一詞，意指我們利用符號的「形式(form)」來解決問題。<p class='footer'>大學資訊系所的一門必修課 "formal language" 中的 "formal" 也為「形式」之意。早期台灣將該門課稱為「正規語言」，可能是將 formal 誤解為相對於 casual 的「正式/正規」。</p></p>
<p>如果我們希望電腦幫我們解問題，需設計的符號就是一套程式語言。這不是一件容易的事：一個程式語言的表達力得強到足以描述所有該語言被設計來解決的問題。一套程式語言是設計者看待世界的抽象觀點。有些程式語言主張世界的狀態可以被一個個指令改變（「把 <code class='haskell'>x</code> 的值更新為 <code class='haskell'>x + y</code>; 在螢幕上畫一個方塊... 」）；有些語言認為世界應該看待為一個個物件；有些語言認為世界是許多彼此傳送訊息的共時程序；有些語言認為只要描述出每個個體之前的邏輯關係，交給電腦推論結果，就是很好的計算模型；本書中將介紹的抽象觀點則主張把一切都看成函數：寫程式是定義函數，圖形是座標到顏色的函數，動畫則是時間到圖形的函數...。</p>
<p>晚近的語言設計，尤其是型別系統的設計，採用了許多邏輯學界的結果。本章談「騎士與惡棍之島」時，使用的是命題邏輯(propositional logic)的一種分支。一套「邏輯」也可視作一群符號以及其規則。許多人可能不知道，邏輯有許多種。命題邏輯是一套簡單的邏輯，其優點是給定任一合法的句子，都有一套機械性作法可得知其成立與否 --- 這個性質稱作「可判定性(decidability)」。但命題邏輯的<em>表達力</em>並不強：許多事情無法在命題邏輯中表達出來。</p>
<p>想表達更細緻的陳述，可使用表達力更強的邏輯。有些邏輯能表達「對所有」、「存在」；有些邏輯能表達先後順序以及「將一直成立」、「將在未來某時間成立」等觀念；有些邏輯可用來表達概念與概念之間的關係。但有得必有失，一套邏輯的表達力只要強到某個程度，就不再有可判定性了，沒有一套固定的方法可知道任意一個邏輯式子的真假。這是理性的限制。在知道形式系統的侷限之下盡力探索並發揮其極限，便是這套學問迷人之處。</p>
<p>因此，設計程式語言時總得掌握這樣的平衡：我們希望語言的表達力強到足以描述我們希望表達的運算程序，但又不希望強到無法掌握其性質。</p>
<h2 class='section' >正確性</h2><p>程式語言是設計者選擇用來看待世界的抽象方式。這樣的選擇必然是基於一些考量：如果設計者希望程式能很容易分割、重用，他可能選擇易於將大問題分解成小問題的觀點。如果設計者希望該語言能有效率很高的實作，這語言看待世界的方式可能就和機器的世界觀很接近。</p>
<p>本書選擇的方向則是「<em>程式語言應能幫助我們確保程式的正確性。</em>」</p>
<p>但什麼是「正確」？直觀說來，一個程式「正確」的意思是該程式「做到了我們要它做的事。」但，電腦本來不就只能一個指令一個動作地做我們要它做的事嗎？那麼「正確」的意思到底是什麼？</p>
<p>我們考慮一下這個問題：</p>
<div>example[最大區段和]<id='ex:mss'><br>
<p>給定一串（有正有負）的數字。請找出一段連續的數字，使其總和越大越好，並傳回這個總和。</p>
example</div>
這是經典的「最大區段和」問題。如前面的章節所述，面對一個問題，我們先把它描述成符號。如果 <code class='haskell'>a</code> 是給定的那串數字，<code class='haskell'>N</code> 是其長度，<code class='haskell'>a[i]</code> 是數字中的地 <code class='haskell'>i</code> 個，而 <code class='haskell'>m</code> 是我們想求出的、最大的那個和，最大區段和問題可以描述成這樣：<br>
\begin{gather}\label{eq:mss-spec-math}
\begin{split}
  m &= max \{sum(i,j) \mid 0 \leq i \leq j \leq N\} \mbox{~~,}\\
  sum (i,j) &= \Sigma^{j-1}_{k=i} a[k] \mbox{~~,}
\end{split}
\end{gather}<br>22
<p>其中 <code class='haskell'>sum (i,j)</code> 代表 <code class='haskell'>a[i]..a[j-1]</code> 的和，而 <code class='haskell'>max S</code> 找出集合 <code class='haskell'>S</code> 中最大的那個。</p>
<p>但（許多讀者可能也知道）這個問題其實有個線性時間內可執行完畢的解：將這串數字 <code class='haskell'>a</code> 從頭到尾看過一遍，維持兩個變數 <code class='haskell'>s</code> 和 <code class='haskell'>m</code>。每看到一個新數字 <code class='haskell'>a[j]</code>, 將 <code class='haskell'>s</code> 更新為 <code class='haskell'>0</code> 與 <code class='haskell'>s + a[k]</code> 中較大的那個，並把 <code class='haskell'>m</code> 更新為 <code class='haskell'>s</code> 與 <code class='haskell'>m</code> 中較大的那個。寫成程式的話，可能是這樣：</p>
<div>verbatim<br>23
   s, m = 0, 0
   for k in range(0,n-1)
     s = max (0, s + a[k])
     m = max (s, m)<br>
verbatim</div>
那麼，明顯的問題來了。上面的程式和問題描述 eqref eq:mss-spec-math 一點也不像。我們怎麼知道程式真正實作了 eqref eq:mss-spec-math 的要求？<br>
<p>由此談「正確性」，相信清楚多了。數學式 eqref eq:mss-spec-math 給的是一個規格(specification)，談的是<em>我們要的結果</em>(<em>what</em>), 而程式描述的則是<em>怎麼做</em>(<em>how</em>). 「正確性」總是相對於一個規格而言的：描述「怎麼做」的程式是否真做到了規格的要求？</p>
<p>「最大區段和」的例子可以給我們幾個啟示。首先，把「要什麼」和「怎麼做」牽上關聯，有時是很困難的。當我們說一個程式「很難懂」，其中一個意思是很難看出「為什麼這個程式實作出了這個規格？」（也就是說「為什麼這個程式是正確的？」）看懂一個程式，也就是了解他為何是正確的。</p>
<p>「最大區段和」的例子也告訴我們，「難懂」的程式不一定要很長。上面的程式短短四行，但若沒有輔助解釋，一般人可能很難「看懂」它。<p class='footer'>理解這個程式的關鍵是：<code class='haskell'>m</code>永遠是<code class='haskell'>a[0]..a[k]</code>中所有連續區段最大的和，而<code class='haskell'>s</code>永遠是<code class='haskell'>a[0]..a[k]</code>中{\em 最右端為<code class='haskell'>a[k]</code>}的連續區段中最大的和。這兩個條件是該迴圈的<em>恆式</em>(<em>loop invariant</em>)。恆式是了解一個迴圈最重要的資訊。</p></p>
<p>如果規格已經不見了呢？這樣的情形更糟。當我們在沒有規格的情況下問一個程式「是做什麼的」，我們真正問的是「這個程式符合的規格是什麼？」這可能是個難題。回頭看看上面的程式，如果沒有給 eqref eq:mss-spec-math ，你能說得出這個程式在做什麼嗎？</p>
<h2 class='section' >可演算的程式語言</h2><p>正確性是如此重要又難以掌握的性質，我們因此希望程式語言能幫助我們確保程式的正確性。我們採用的方法是：給定一個規格，我們希望正確的程式能夠由其規格演算、推導出來。就如同在騎士與惡棍問題中，我們把希望 <code class='haskell'>Q</code> 滿足的性質寫下，然後利用符號的規則算出 <code class='haskell'>Q</code>. 我們希望程式也能如此從其規格被<em>算</em>出來。</p>
<p>以最大區段和問題為例，用我們之後將介紹的符號，我們可以把\eqref{eq:mss-spec-math}改寫成：</p>
<div><pre class='spec'>
  mss = max . map sum . segments {-"~~,"-}
</pre></div>
其意思大約是「給定一串數字，找出它的所有連續區段，算每一個區段的和，然後傳回其中最大的。」接下來的問題是，<code class='haskell'>mss</code> 有沒有比較快的實作？我們希望可以用代數方法，由 <code class='haskell'>mss</code> 的規格出發：<br>
<div><pre class='spec'>
   max . map sum . segments
=    {- |segments| 的定義 -}
   max . map sum . concat . map inits . tails
=    {- 某定理 -}
   ...
=    {- 另一些定理 -}
   max . scanr oplus 0 {-"~~."-}
</pre></div>
最後的 <code class='haskell'>max . scanr oplus 0</code> 相當於前一節的程式，只是以不同的符號表示。<br>
<p>我們可以由規格出發，在符號上操作，將程式如同求代數的解一樣地算出來。只要每個小步驟都正確，最後的程式就是正確的。這套技術稱作「程式推導(program derivation)」 index program derivation 程式推導 或「程式演算(program calculation)」 index program calculation 程式演算 ，將是本書重要的主題。而在本書的觀點中，函數編程相較於其他典範的特色與優勢是<em>函數語言是一套適合演算的符號系統</em>。</p>
適合演算的符號  我們舉個例子，談談符號「適合演算」是怎麼回事。圖 ref fig:greekalphnumerals 中顯示的是西元前四世紀左右希臘人使用的數字表示法。以希臘字母表為順序，$1$, $2$,\ldots 到 $9$ 分別寫成 \textalpha, \textbeta,\ldots \straighttheta.每遇到 $10$ 的乘冪便換一組符號，如 $10$, $20$, \ldots 寫成\textiota, \textkappa \ldots。$11$, $12$, $13$ 分別寫成 \textiota\textalpha, \textiota\textbeta, \textiota\textgamma,$21$, $22$, $23$ 則寫成 \textkappa\textalpha, \textkappa\textbeta, \textkappa\textgamma.$653$可寫成\textchi\textnu\textgamma.這套表示法的缺點包括不易表示大數，以及不易做演算：我們需要知道 \textdelta 加上 \textbeta 等於 \foreignlanguage{greek}{\stigma}, 以及 \textmugreek 加上 \textkappa 等於 \textxi。<p class='footer'>西元前八世紀，希臘人曾使用以 I, \textPi, \textDelta, H 分別表示 $1$, $5$, $10$, $100$ 的表示法。後來被圖 ref fig:greekalphnumerals 中的系統取代。無論如何，希臘人仍以此發展出了進步的數學。</p><br>
\newcommand{\greekalphnumerals}{
\begin{tabular}{*{18}{r}}
  \textalpha & \textbeta & \textgamma & \textdelta & \textepsilon &
  \foreignlanguage{greek}{\stigma}   & \textzeta & \texteta & \straighttheta & \textiota &
  \textkappa & \textlambda & \textmugreek & \textnu & \textxi &
  \textomikron & \textpi & ϙ
  %\foreignlanguage{greek}{\coppa}
  \\
  1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 &
  20 & 30 & 40 & 50 & 60 & 70 & 80 & 90\\
\end{tabular}\\
\begin{tabular}{*{21}{r}}
  \textrho & \textsigma & \texttau & \textupsilon & \textphi &
  \textchi & \textpsi & \textomega & \foreignlanguage{greek}{\sampi} & \foreignlanguage{greek}{\greeknumeral{1000}} & \foreignlanguage{greek}{\greeknumeral{2000}}  & \foreignlanguage{greek}{\greeknumeral{3000}} \\
  100 & 200 & 300 & 400 & 500 & 600 & 700 & 800 & 900 &
  1000 & 2000 & 3000
\end{tabular}
}<br>22
<img src='[t]<br>5
<div>center
  \greekalphnumerals<br>22
center</div>
\caption{希臘數字。}<br>8
<id='fig:greekalphnumerals'><br>6
'><br>7
\newcommand{\mayalargenumber}{%
\begin{tabular}{cl}
  $\mayadigit{1}$ & $1 \times 18 \times 20 \times 20 \times 20 \times 20 = 2880000$\\
  $\mayadigit{2}$ & $2 \times 18 \times 20 \times 20 \times 20 = 288000$ \\
  $\mayadigit{6}$ & $6 \times 18 \times 20 \times 20 = 43200$ \\
  $\mayadigit{2}$ & $2 \times 18 \times 20 = 720$ \\
  $\mayadigit{13}$ & $13 \times 20 = 260$\\
$\mayadigit{19}$  & $19$ \\
  & 總和: 3212199
\end{tabular}}
\newcommand{\mayaaddition}{%
\begin{tabular}{ccccccc}
    $\mayadigit{7}$  & & $\mayadigit{2}$   &  &$\mayadigit{9}$ & & $\mayadigit{10}$ \\[-0.15cm]
    $\mayadigit{11}$ & + & $\mayadigit{15}$  & = & $\mayadigit{26}$ & =& $\mayadigit{6}$\\
    151  & & 55 & & 206 & & 206
\end{tabular}}<br>22
<p>與之對比的是瑪雅數字。這套數字系統的年代不詳，據估計可能在西元四至世紀採用。一個點代表 $1$, 一條橫杠代表 $5$。 例如 $19$ 寫成 $\mayadigit{19}$. 瑪雅數字採用 $20$ 進位，較大的位數寫在上方。因此</p>
\begin{align*}
\mayadigit{7}\\[-0.35cm]
\mayadigit{11}
\end{align*}<br>22
代表 $7 (\mayadigit{7}) \times 20 + 11 (\mayadigit{11})$, 也就是 $151$.另有個例外：第三個數字為 $18$（而非 $20$）的乘冪 --- 因為 $18 \times 20 = 360$ 接近一年的日數。圖 \ref{fig:mayanumerals} 中左邊由上至下是以瑪雅數字寫成的 $3212199$.值得注意的是，此類<em>以符號的位置表示其量級</em>的數字表示法大都需要一個相當於「零」的佔位符號。在瑪雅數字中，該符號寫成 $\mayadigit{0}$。因此 $20$ 可寫成 $\dot{\raisebox{-1pt}{\vstretch{0.7}{\mayadigit{0}}}}$, 與只有一個點的 $1$ 區分。<p class='footer'>一些早期數字表示法中有此種佔位符號，但並不見得把「零」視為可獨立存在的一個數。「將零視為一個數字」是數學史上的重要發明，許多數學性質都需有它的存在才得以描述。程式語言中也有類似的情況：有一個「不做任何事的指令」或一個「將輸入照樣傳回的函數(即<code class='haskell'>id</code>)」對於描述程式的性質是很重要的。</p><br>
<img src='[t]<br>5
<div>center
\mayalargenumber<br>22
center</div>
\caption{以瑪雅數字表示 $3212199$.}<br>8
<id='fig:mayanumerals'><br>6
'><br>7
<p>如何用瑪雅數字作加法？以下顯示的是 $151 + 55$:</p>
\begin{align*}
\mayaaddition
\end{align*}<br>22
我們可先把兩個個位數（$\mayadigit{11}$與$\mayadigit{15}$）和兩個 $20$ 位數（$\mayadigit{7}$與$\mayadigit{2}$）分別相加。其中，個位數相加的結果是 $\mayadigit{26}$ --- 超過了 $20$！於是我們把其中四個橫槓（即一個 $20$）往上進位成一個點，和 $20$ 位數的四個點結合成另一個橫槓。<br>
<p>有趣的是，我相信大部分的讀者即使可能是第一次看到這種數系，也從未使用過 $20$ 進位，還是可迅速理解以上的加法，甚至可以舉一反三地自己試試看。這就是一個<em>適合演算</em>的符號系統給我們的便利。</p>
<p>對本書來說，函數語言的價值便是 --- 它是個適於演算的語言。</p>
<h2 class='section' >相關資料</h2><p>本章中的騎士與惡棍問題所使用的邏輯形式稱作<em>演算邏輯</em>(calculational logic) index calculational logic 演算邏輯 ，其主要精神是將命題邏輯與述語邏輯表達為適合用於等式推導與演算的形式。 citet GriesSchneider:03:Calculational  認為大部分形式邏輯系統是為了研究邏輯本身的特性而設計，而演算邏輯則是為了以邏輯解決問題而開發的。演算邏輯由程式語言學者們於 80 年代初期漸漸發展出來。<p class='footer'> citet GriesSchneider:03:Calculational  將此歸功於 Roland Backhouse, Edsger W. Dijkstra, Wim H.J. Feijen, David Gries, Carel S. Scholten, 以及 Netty van Gasteren 等人。他們的共同研究主題是以形式方法開發程式。</p> citet DijkstraScholten:90:Predicate  將演算邏輯用於指令式程式語言的語意中。本章中的騎士與惡棍問題由  citet Backhouse:03:Program  中節錄而來。這是一本介紹以形式方式構思演算法以解決問題的教科書。本章只用到了 <code class='haskell'>(<=>)</code> 一個運算子，該書中則有更完整的介紹。 citet GriesSchneider:93:Logical  則是一本以演算邏輯為基礎的離散數學教科書。</p>
<p>「讓符號為你工作」這句口號可在 Dijkstra 的許多著作中見到（例如  citet Dijkstra:86:OnNaming  ,  citet Dijkstra:00:Notational ）。 citet Dijkstra:04:Next  寫道：「設計程式的人最好把程式當作精巧的算式。而我們知道只有一種設計精巧算式的可靠方法：用符號操作來推導它。我們得讓符號為我們工作，因為這是已知唯一在大尺度下仍可行的方法。」Misra 則在 1988 年 Marktoberdorf 暑期課程的演講 \citep{Misra:89:Visionary} 中虛構了一個故事：使用羅馬數字的羅馬人被推銷比較易於演算的印度-阿拉伯數字系統，卻不以為然地說「我們已經有奴隸為我們工作了！」% We also know that, while from an operational point of view a program can be nothing but an abstract symbol manipulator, the designer had better regard the program as a sophisticated formula. And we also know that there is only one trustworthy way for the design of sophisticated formulae, viz. derivation by means of symbol manipulation. We have to let the symbols do the work, for that is the only known technique that scales up.</p>
<p>希臘與瑪雅數字的例子取自  citet Mazur:14:Enlightening 。該書對於種種符號的演進有更詳盡的介紹。</p>
</div>
</div>
</body>
</html>
